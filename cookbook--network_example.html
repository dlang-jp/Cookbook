
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>network_example</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <h2>cookbook</h2>
        <p><span class="smallprint"><b>version:</b> ~master <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	

	<li><a href="cookbook--array_example.html"><span >配列</span></a></li>



	<li><a href="cookbook--assoc_array_example.html"><span >連想配列</span></a></li>



	<li><a href="cookbook--concurrency_example.html"><span >並行処理</span></a></li>


	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >データ形式
		</span></a><ul><li><a href="
			cookbook--data.html"><span >overview</span></a></li>
			

	<li><a href="cookbook--data.csv_example.html"><span >CSV操作</span></a></li>



	<li><a href="cookbook--data.json_example.html"><span >JSON操作</span></a></li>

</ul></li>
	
	





	<li><a href="cookbook--datetime_example.html"><span >時刻・日付</span></a></li>



	<li><a href="cookbook--file_example.html"><span >ファイルシステム</span></a></li>



	<li><a href="cookbook--getopt_example.html"><span >コマンドライン解析</span></a></li>



	<li><a href="cookbook--is_example.html"><span >is式</span></a></li>



	<li><a href="cookbook--meta_example.html"><span >メタプログラミング</span></a></li>



	<li><a href="cookbook--network_example.html"><span >ネットワーク(cURL)</span></a></li>



	<li><a href="cookbook--process_example.html"><span >プロセス</span></a></li>



	<li><a href="cookbook--random_example.html"><span >乱数</span></a></li>



	<li><a href="cookbook--range_example.html"><span >レンジ</span></a></li>



	<li><a href="cookbook--regex_example.html"><span >正規表現</span></a></li>



	<li><a href="cookbook--string_example.html"><span >文字列</span></a></li>



	<li><a href="cookbook--uda_example.html"><span >UDA(User Defined Attribute)</span></a></li>





	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >subpkg</span></a><ul>
			

	<li><a href="cookbook-subpkg--subpkg.test.html"><span >サブパッケージの作り方</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >windows</span></a><ul>
			

	<li><a href="cookbook-windows--windows.basic.html"><span >Win32API</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >libdparse_usage</span></a><ul>
			

	<li><a href="cookbook-libdparse_usage--libdparse_usage.example.html"><span >libdparse</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                
                <div class="quickindex" id="quickindex"></div>
                
                <h1><div class="ddoc_summary">ネットワーク(cURL)
</div></h1><div class="ddoc_description">ネットワークモジュール、特に <span class="d_inlinecode donthyphenate notranslate">std.net.curl</span> の使い方についてまとめます。
<div class="ddoc_blankline"></div>

HTTP通信などができます。</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 HTTPでGET
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.net.curl;
<span class="d_keyword">import</span> std.array: appender;
<span class="d_keyword">import</span> std.algorithm: countUntil;

<span class="d_comment">// ごく単純なGET
</span><span class="d_keyword">auto</span> contents1 = get(<span class="d_string">"https://dlang.org"</span>);


<span class="d_comment">// 細かな設定を行うGET
</span><span class="d_keyword">auto</span> client = HTTP();
<span class="d_comment">// こんな感じでいろいろクライアントの設定を行う
</span><span class="d_comment">// (ちなみにこの設定はリダイレクトを30回まで行う設定)
</span>client.maxRedirects = 30;
<span class="d_comment">// get関数の２番目の引数に指定する
</span><span class="d_keyword">auto</span> contents2 = get(<span class="d_string">"https://dlang.org"</span>, client);
<span class="d_keyword">assert</span>(contents2 == contents1);


<span class="d_comment">// 生データをGET
</span><span class="d_keyword">auto</span> contents3 = appender!(<span class="d_keyword">char</span>[])();
client = HTTP();
client.url = <span class="d_string">"https://dlang.org"</span>;
<span class="d_comment">// データが分割して送られてくるのをコールバックでハンドリング
</span>client.onReceive = (<span class="d_keyword">void</span>[] buf)
{
    contents3 ~= <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>[])buf;
    <span class="d_keyword">return</span> buf.length;
};
<span class="d_comment">// GET
</span>client.method = HTTP.Method.get;
<span class="d_comment">// ここでネットワークと接続
</span>client.perform();

<span class="d_comment">// getで得たcontents1～2と、contents3の生データの内容は同一ではありません。
</span><span class="d_comment">// getで得たものは、文字コードのエンコードが行われています。
</span><span class="d_comment">// このため、エンコーダがデフォルトで存在していないShift_JISなどの
</span><span class="d_comment">// 文字コードのWEBページをGETしようとすると例外が発生します。
</span><span class="d_comment">/* ※ 一致するかどうかが不明のため
      ここではコンパイルできるかどうかだけチェックします */</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(compiles,
    <span class="d_keyword">assert</span>(contents1 == <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">char</span>[])contents3.data)));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 文字コードの話
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.net.curl;
<span class="d_keyword">import</span> std.array: appender;
<span class="d_keyword">import</span> std.exception: assertThrown;
<span class="d_keyword">import</span> std.algorithm: countUntil;

<span class="d_comment">// 試しに今どき珍しいEUC-JPを使用しているSeesaa WikiをGET!
</span>get(<span class="d_string">"https://wiki.seesaa.jp/"</span>).assertThrown();

<span class="d_keyword">auto</span> client = HTTP();
<span class="d_keyword">auto</span> contents = appender!(<span class="d_keyword">char</span>[])();
client.url = <span class="d_string">"https://wiki.seesaa.jp/"</span>;
client.onReceive = (<span class="d_keyword">void</span>[] buf)
{
    contents ~= <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>[])buf;
    <span class="d_keyword">return</span> buf.length;
};
client.perform();
<span class="d_keyword">auto</span> buf = contents.data;
<span class="d_comment">// 生データならEUC-JPでもちゃんと受信できます。
</span><span class="d_comment">// UTF-8ではないので、バイト列にEUC-JPが含まれるか検索してみます。
</span><span class="d_keyword">assert</span>(countUntil(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">ubyte</span>[])buf,
                  <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">ubyte</span>[])<span class="d_string">"charset=EUC-JP"c</span>) &lt; buf.length);
<span class="d_keyword">version</span> (Windows)
{
    <span class="d_comment">// Windowsだとこのようにして文字コードを変換できます。
</span>    <span class="d_keyword">import</span> std.windows.charset;
    <span class="d_comment">// EUC-JPだと例外を投げるような文字列の検索も
</span>    buf.countUntil(<span class="d_string">"&lt;/body&gt;"</span>).assertThrown;
    contents ~= <span class="d_string">"\0"</span>;
    buf = contents.data;
    <span class="d_comment">// 文字コード変換(EUC-JP(20932)からUTF-8)することで
</span>    <span class="d_keyword">auto</span> contents2 = fromMBSz(<span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span> <span class="d_keyword">char</span>*)buf.ptr, 20_932);
    <span class="d_comment">// 検索できるようになります
</span>    <span class="d_keyword">assert</span>(contents2.countUntil(<span class="d_string">"&lt;/body&gt;"</span>) &lt; contents2.length);
}
<span class="d_comment">// TODO: Linuxなどでの文字コード変換方法
</span><span class="d_comment">// TODO: std.encodingへの文字コード変換器登録方法
</span></pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 認証付きProxyを通す
<pre class="d_code notranslate"><span class="d_keyword">import</span> etc.c.curl: CurlAuth, CurlOption, CurlProxy;
<span class="d_keyword">import</span> std.net.curl;

<span class="d_keyword">auto</span> client = HTTP();
<span class="d_comment">// Proxyのホスト名を指定します
</span>client.proxy = <span class="d_string">"proxy.host.name"</span>;
<span class="d_comment">// Proxyのポート番号を指定します
</span>client.proxyPort = 8080;
<span class="d_comment">// Proxyの種類を指定します。デフォルトはhttpです。
</span>client.proxyType = CurlProxy.http;
<span class="d_comment">// Proxyの認証データのユーザー名を指定します。
</span>client.setProxyAuthentication(<span class="d_string">"username"</span>, <span class="d_string">"password"</span>);
<span class="d_comment">// 認証方式を指定する場合はこう
</span>client.handle.set(CurlOption.proxyauth, CurlAuth.basic);

<span class="d_comment">// あとはgetするなど、ほかの操作と同じです
</span><span class="d_comment">/* ※ ここでは実在のURLやパスワードを指定していないので、
      コンパイルできるかどうかだけチェックします */</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(compiles,
    get(<span class="d_string">"http://hogehoge.net"</span>, client)));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 クライアント認証する
<div class="ddoc_blankline"></div>

CurlOption.sslcertなどのオプションを使用します。

<ul><li>WindowsではDMDやLDCにOpenSSLがリンクされていないlibcurl.dllが使われているようですが
   クライアント認証にはOpenSSLが必要となりますので、OpenSSLがリンクされたlibcurl.dllを使用する必要があります。<br></li>
<li>さらに、cURLの公式で配布している64bitのDLLは libcurl-x64.dll という名称ですが、<span class="d_inlinecode donthyphenate notranslate">std.net.curl</span>が使用するDLLの名称は<span class="d_inlinecode donthyphenate notranslate">libcurl.dll</span>または<span class="d_inlinecode donthyphenate notranslate">curl.dll</span>固定です。
   このため、ファイル名を変更する必要があります。</li>
<li>また、OpenSSLのDLL<span class="d_inlinecode donthyphenate notranslate">libcrypto-1_1-x64.dll</span>、<span class="d_inlinecode donthyphenate notranslate">libssl-1_1-x64.dll</span>なども用意します。
</li>
</ul>
なお、CA証明書、クライアント証明書や秘密鍵の生成方法・変換方法はここでは解説いたしません。
<pre class="d_code notranslate"><span class="d_keyword">import</span> etc.c.curl: CurlAuth, CurlOption, CurlProxy;
<span class="d_keyword">import</span> std.net.curl;

<span class="d_keyword">auto</span> client = HTTP();
<span class="d_comment">// CA証明書のPEM形式ファイルを指定します
</span>client.caInfo = <span class="d_string">"cacert.pem"</span>;

<span class="d_comment">// クライアント証明書に暗号化された秘密鍵がついている場合
</span>{
    <span class="d_comment">// 秘密鍵付きのクライアント証明書のPEM形式ファイルを指定します
</span>    client.handle.set(CurlOption.sslcert,     <span class="d_string">"clcert.pem"</span>);
    <span class="d_comment">// 形式はPEMです(デフォルトはPEM)
</span>    client.handle.set(CurlOption.sslcerttype, <span class="d_string">"PEM"</span>);
    <span class="d_comment">// クライアント証明書に秘密鍵がついている場合、パスワードを指定します
</span>    client.handle.set(CurlOption.keypasswd,   <span class="d_string">"password"</span>);
}

<span class="d_comment">// クライアント証明書に秘密鍵が含まれておらず
</span><span class="d_comment">// 別途暗号化された秘密鍵を指定する場合
</span>{
    <span class="d_comment">// クライアント証明書のPEM形式ファイルを指定します
</span>    client.handle.set(CurlOption.sslcert,     <span class="d_string">"clcert.pem"</span>);
    <span class="d_comment">// クライアント証明書の形式を指定(デフォルトはPEM)
</span>    client.handle.set(CurlOption.sslcerttype, <span class="d_string">"PEM"</span>);
    <span class="d_comment">// 暗号化された秘密鍵のPEM形式ファイルを指定します
</span>    client.handle.set(CurlOption.sslkey,      <span class="d_string">"key.pem"</span>);
    <span class="d_comment">// 秘密鍵の形式を指定(デフォルトはPEM)
</span>    client.handle.set(CurlOption.sslkeytype,  <span class="d_string">"PEM"</span>);
    <span class="d_comment">// 暗号化した秘密鍵を指定した場合、パスワードを指定
</span>    client.handle.set(CurlOption.keypasswd,   <span class="d_string">"password"</span>);
}

<span class="d_comment">// クライアント証明書に秘密鍵が含まれておらず
</span><span class="d_comment">// 復号化された秘密鍵を指定する場合
</span>{
    <span class="d_comment">// クライアント証明書のPEM形式ファイルを指定します
</span>    client.handle.set(CurlOption.sslcert,     <span class="d_string">"clcert.pem"</span>);
    <span class="d_comment">// クライアント証明書の形式を指定(デフォルトはPEM)
</span>    client.handle.set(CurlOption.sslcerttype, <span class="d_string">"PEM"</span>);
    <span class="d_comment">// 復号化された秘密鍵のPEM形式ファイルを指定します
</span>    client.handle.set(CurlOption.sslkey,      <span class="d_string">"decrypted-key.pem"</span>);
    <span class="d_comment">// 秘密鍵の形式を指定(デフォルトはPEM)
</span>    client.handle.set(CurlOption.sslkeytype,  <span class="d_string">"PEM"</span>);
    <span class="d_comment">// 復号化された秘密鍵を指定した場合、パスワードは不要
</span>    <span class="d_comment">//client.handle.set(CurlOption.keypasswd,   "不要");
</span>}

<span class="d_comment">// あとはgetするなど、ほかの操作と同じです
</span><span class="d_comment">/* ※ ここでは実在のファイルを指定していないので、
      コンパイルできるかどうかだけチェックします */</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(compiles,
    get(<span class="d_string">"http://hogehoge.net"</span>, client)));
</pre>
</div>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>