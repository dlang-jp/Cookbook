[
 {
  "name" : "array_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/array_example.d",
  "comment" : "配列\n\n動的配列と静的配列の操作についてまとめます。\n\n要素の初期化、要素の追加、要素の削除、ソート(WIP)、ループ操作(WIP)\n\nSource: $(LINK_TO_SRC source/_array_example.d)\nMacros:\n    TITLE=配列を扱う例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "初期化の例です\n",
    "line" : 17,
    "char" : 1,
    "endline" : 31,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L31_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "二次元以上の多次元配列を一括で確保する例です\n",
    "line" : 31,
    "char" : 1,
    "endline" : 53,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L53_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "要素のインデックス、または条件式を指定した値の削除\n\n`std.algorithm` の `remove` を使います\n\n`remove` : $(LINK https://dlang.org/phobos/std_algorithm_mutation.html#.remove)\n",
    "line" : 53,
    "char" : 1,
    "endline" : 71,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L71_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "要素の追加の例です。\n\n動的配列に対しては `~=` 演算子で要素を追加することができます。\n",
    "line" : 71,
    "char" : 1,
    "endline" : 88,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L88_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "事前にサイズがわからない配列を構築する場合は `std.array` の `appender` を使用すると効率的です。\n\n要素の追加は `~=` または `put` で行います。\n\n`appender` : $(LINK https://dlang.org/phobos/std_array.html#appender)\n",
    "line" : 88,
    "char" : 1,
    "endline" : 101,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "assoc_array_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/assoc_array_example.d",
  "comment" : "連想配列\n\n連想配列の操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_assoc_array_example.d)\nMacros:\n    TITLE=連想配列を扱う例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# データ操作\n",
    "line" : 15,
    "char" : 1,
    "endline" : 70,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L70_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# プロパティ\n",
    "line" : 70,
    "char" : 1,
    "endline" : 116,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L116_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 空連想配列とnull\n",
    "line" : 116,
    "char" : 1,
    "endline" : 140,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "concurrency_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/concurrency_example.d",
  "comment" : "並行処理\n\n`std.concurrency` を使った並行処理の例をまとめます。\n\nSource: $(LINK_TO_SRC source/_concurrency_example.d)\nMacros:\n    TITLE=並行処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ファイルの書き込みを専用のスレッドで処理することで、大量の書き込みを効率良く行う例です。\n\nこれは主に大量の繰り返し計算に伴うログの記録や計算の途中経過を保存する場合のパターンとして役立ちます。\n",
    "line" : 17,
    "char" : 1,
    "endline" : 94,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L94_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "前述の大量書き込みの例に対し、起動する処理を使いまわしが可能な関数として定義する例です。\n\n実行に必要なパラメーターを引数として宣言しておくとspawnの際に渡すことができます。\n",
    "line" : 94,
    "char" : 1,
    "endline" : 151,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "container_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/container_example.d",
  "comment" : "コンテナ\n\nスタックやキューなど、いくつかのデータ構造を実現する方法についてまとめます。\n\nSource: $(LINK_TO_SRC source/_container_example.d)\nMacros:\n    TITLE=コンテナ（データ構造）の例\n",
  "members" : [
   {
    "name" : "__unittest_L24_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "スタックを構成する例です。\n\nスタックは、後入れ先出し（LIFO: Last In, First Out）のデータ構造です。\n要素の追加順に対し、後から追加した最も新しい要素が取り出されます。\n\n汎用データ構造である `std.container` の `SList` を利用して実現します。\nSListは「単方向リンクリスト（Single Linked List）」であり、先頭要素の追加や削除が高速（定数時間）です。\nこれはスタックの動作に沿っており、パフォーマンスの面からも優れています。\n\nSee_Also: https://dlang.org/phobos/std_container_slist.html\n",
    "line" : 24,
    "char" : 1,
    "endline" : 65,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L65_C1",
    "kind" : "function",
    "protection" : "public",
    "line" : 65,
    "char" : 1,
    "endline" : 94,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L94_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "キューを構成する例です\n\nキューは、先入れ先出し（FIFO: First In, First Out）のデータ構造です。\n要素の追加順に対し、最初に追加した最も古い要素が取り出されます。\n\n汎用データ構造である `std.container` の `DList` を利用して実現します。\nDListは「双方向リンクリスト（Double Linked List）」であり、先頭と末尾に対する追加や削除が高速（定数時間）です。\nこれはキューの動作に沿っており、パフォーマンスの面からも優れています。\n\nSee_Also: https://dlang.org/phobos/std_container_dlist.html\n",
    "line" : 94,
    "char" : 1,
    "endline" : 147,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L147_C1",
    "kind" : "function",
    "protection" : "public",
    "line" : 147,
    "char" : 1,
    "endline" : 163,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "data",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/data/package.d",
  "comment" : "データ形式\n\n特定のデータ形式を取り扱う例をまとめました\n\n$(DL\n    $(DT $(A cookbook--_data.base64_example.html, Base64))\n    $(DD\n        `std.base64`を用いてBase64形式でのデータのエンコード/デコードを取り扱います。\n    )\n    $(DT $(A cookbook--_data.csv_example.html, CSV))\n    $(DD\n        `std.csv`を用いてCSV形式のデータを取り扱います。 $(BR)\n        また、`std.csv`ではサポートされていないCSVの書き出し方についても取り扱います。\n    )\n    $(DT $(A cookbook--_data.json_example.html, JSON))\n    $(DD\n        `std.json`を用いてJSON形式のデータを取り扱います。 $(BR)\n        数値型や文字列型、真偽値型、配列や連想配列と、JSONデータ型との相互変換やJSONファイルの読み書きを行います。\n    )\n    $(DT $(A cookbook--_data.zip_example.html, ZIP))\n    $(DD\n        `std.zip`を用いてZIP形式のデータの圧縮・解凍を取り扱います。 $(BR)\n        ディレクトリ階層の再現、日本語ファイル名の取り扱いについても取り扱います。\n    )\n)\n\nSource: $(LINK_TO_SRC source/_data/package.d)\n",
  "members" : [
   {
    "name" : "data.csv_example",
    "kind" : "import",
    "line" : 32,
    "char" : 15
   },
   {
    "name" : "data.json_example",
    "kind" : "import",
    "line" : 33,
    "char" : 15
   },
   {
    "name" : "data.zip_example",
    "kind" : "import",
    "line" : 34,
    "char" : 15
   }
  ]
 },
 {
  "name" : "data.base64_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/data/base64_example.d",
  "comment" : "Base64エンコード/デコード\n\nBase64のエンコードとデコードを行うサンプルです\n\nSee_Also:\n    - https://dlang.org/phobos/std_base64.html\n\nSource: $(LINK_TO_SRC source/data/_base64_example.d)\n",
  "members" : [
   {
    "name" : "__unittest_L16_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Base64エンコード/デコードを行うサンプルです\n",
    "line" : 16,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 30,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L30_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Base64エンコード/デコードの保存先をOutputRangeにすることもできます\n",
    "line" : 30,
    "char" : 1,
    "endline" : 48,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L48_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Base64エンコード/デコードの入力元をInputRangeにすることもできます\n",
    "line" : 48,
    "char" : 1,
    "endline" : 65,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "data.csv_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/data/csv_example.d",
  "comment" : "CSV操作\n\nCSVファイル/CSVデータの読み書き等操作を扱います。\nここでは、標準で備えているstd.csvモジュールを用いたCSVファイルの読み込みと、\nCSVファイルへの書き出しについて説明します。\n\nSource: $(LINK_TO_SRC source/data/_csv_example.d)\n",
  "members" : [
   {
    "name" : "__unittest_L18_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# CSVのパース\n",
    "line" : 18,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 42,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L42_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "もう少し複雑な場合\n",
    "line" : 42,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 89,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L89_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "構造体でデータ構造をレイアウトする場合\n",
    "line" : 89,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 135,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L135_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# CSVの書き出し\n\n残念ながら、CSVを書き出す機能はありません。自分で作ります。\n以下の例では汎用性を高めるため、`\",\\n`を含むものを変換することを前提とします。\nこれらが含まれると、各セルをエスケープする必要が出るためです。\n数値だけということがあらかじめわかっているときなど、\nエスケープする必要がない場合は`format!\"%-(%-(%-s,%)\\n%)\"(mat)`とするだけでOK。\n",
    "line" : 135,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 182,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "data.json_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/data/json_example.d",
  "comment" : "JSON操作\n\nJSONファイル/JSONデータの読み書き等操作を扱います。\nここでは、標準で備えているstd.jsonモジュールと、その中のJSONValueについて説明します。\nこのモジュールは、あくまでもJSONが最低限取り扱える程度の機能があって、速度や利便性は二の次です。\nほかにもサードパーティのライブラリとして、asdfを代表として、より高度な取り扱いができるライブラリがあります。\n\nSource: $(LINK_TO_SRC source/data/_json_example.d)\n",
  "members" : [
   {
    "name" : "__unittest_L17_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 文字列⇔JSON\n",
    "line" : 17,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 37,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L37_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 数値⇔JSON\n",
    "line" : 37,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 86,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L86_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 真偽値・null⇔JSON\n\n真偽値(true / false)とnullの状態は、上記文字列や数値とは異なり、\nそれぞれ個別にJSONTypeが存在します。\n",
    "line" : 86,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 123,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L123_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 配列⇔JSON\n",
    "line" : 123,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 165,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L165_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 連想配列⇔JSON\n",
    "line" : 165,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 226,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L226_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# JSONファイルの書き込み・読み込み\n",
    "line" : 226,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 269,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "data.zip_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/data/zip_example.d",
  "comment" : "ZIP操作\n\n`std.zip`を用いてZIP形式のデータの圧縮・解凍を取り扱います。\nディレクトリ階層の再現、日本語ファイル名の取り扱いについても取り扱います。\n",
  "members" : [
   {
    "name" : "__unittest_L14_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ZIP圧縮ファイルの作成と解凍\n\nSee_Also: https://dlang.org/phobos/std_zip.html\n",
    "line" : 14,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 95,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L95_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "日本語ファイル名の保存方法\n\n日本語のファイル名を保存し、かつプラットフォーム依存をなくすには、工夫が必要です。\n\n具体的には、各`ArchiveMemver`の`extra`に、Info-ZIP Unicode Path Extra Field、というものを使用します。このExtra Fieldが設定されている場合、`ArchiveMemver`の`name`より優先してこのパス名が使用されます。\n\nただし、Unicode Path Extra Field非対応のツールでは`name`に指定したパスが利用されてしまうので、その対応のため、`ArchiveMemver`の`name`にはShift_JISのファイル名を指定します。\n\nSee_Also:\n- https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\n- (和訳) http://www.awm.jp/~yoya/cache/www.geocities.jp/awazou_the_8/pkzip-j.txt\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 95,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 188,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "datetime_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/datetime_example.d",
  "comment" : "時刻・日付\n\n時刻・日付の操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_datetime_example.d)\nMacros:\n    TITLE=時刻や日付操作の例\n",
  "members" : [
   {
    "name" : "__unittest_L19_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 時間を表す7つの型\n\nDには日時に関する型が複数定義されており、その性質によって役割が異なります。\n\n以下の説明では、「システムタイム(日時)」「日時」「日付」「時刻」「時間」「モノトニックタイム(時間)」「期間」を明確に使い分けます。\n",
    "line" : 19,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 33,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L33_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "\n## 1. 「時間」 $(D Duration)\nDurationは「時間」を表す型です。\nここでの「時間」とは、10秒間とか、3時間、のような、時間的な長さを表す表現です。\n各種単位の「時間」を得るには、hours関数や、seconds関数のようなものを core.time からimportして使います。\n",
    "line" : 33,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 54,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L54_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 2. 「システムタイム(日時)」 $(D SysTime)\n\nSysTimeは「時差を考慮した日時」を表す型です。\n現在日時を取得するには、 std.datetime でimportできるClockのメソッドを使用します。\n",
    "line" : 54,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 73,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L73_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 3. 「日時」 $(D DateTime)\n\nDateTimeは「時差を考慮しない日時」を表す型です。\nSysTimeは時差を考慮しますが、DateTimeは考慮せず、ただ\n何年何月何日の何時何分何秒という情報だけを持っています。\nミリ秒以下の情報も持ちません。\n",
    "line" : 73,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 92,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L92_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 4. 「日付」 $(D Date)\n\nDateは、DateTimeのうち、何年何月何日(つまり日付)の部分です。\n",
    "line" : 92,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 127,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L127_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 5. 「時刻」$(D TimeOfDay)\n\nTimeOfDayは、DateTimeのうち、「何時何分何秒」の部分です。\n",
    "line" : 127,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 141,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L141_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 6. 「期間」 $(D Interval)\n\n2つの「時刻」の間の時間を「期間」とすることができます。\n",
    "line" : 141,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 158,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L158_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 7. 「モノトニックタイム(時間)」 $(D MonoTime)\n\n2つ目の「時間」 MonoTime は、ベンチマークやゲームのFPSの計算などで使用される、\n高精度な時間単位を扱います。\nまた、NTPによる巻き戻しがおこらず、単調増加(monotonic)であることが特徴です。\n「時間」を測定するストップウォッチで得られます。\n",
    "line" : 158,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 178,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L178_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# SysTimeと文字列の変換\n",
    "line" : 178,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 221,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L221_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# Durationの使い方\n",
    "line" : 221,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 249,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L249_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# StopWatchの使い方\n",
    "line" : 249,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 305,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L305_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# タイムゾーンの扱い\n",
    "line" : 305,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 341,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L341_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 「今日」の日付を得る\n",
    "line" : 341,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 354,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L354_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 値の構築方法に関するパターン\n\nstd.datetimeの各型は、値の直接指定か、ベースとなる型＋付加情報、というパターンでコンストラクタを使って構築します。\n",
    "line" : 354,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 388,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L388_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# DateTimeからDateを得るなど、上位の複合型から一部を取り出す方法\n\n多くの場合、目的の部分型を得るためのプロパティがあります。\nDateTime型の場合は `date` と `timeOfDay` プロパティで取り出します。\nInterval型の場合は `begin` と `end` プロパティで取り出します。\n\nSysTime型の場合は、DateTime型やDate型へ直接キャストすることで部分型を得ることができます。\n",
    "line" : 388,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 421,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L421_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# Unix timeとSysTimeの相互変換方法、Unix timeの作成方法\n\nUnix timeは UTC時間の1970年1月1日 0時0分0秒からの秒数となります。\nこれはタイムゾーンがUTC基準と定められていることから、\nタイムゾーン情報を持つ SysTimeのみ が相互変換の方法を提供しています。\n",
    "line" : 421,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 457,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "exception_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/exception_example.d",
  "comment" : "例外\n\nD言語は「例外機構」をもつ言語です。\nここでいう例外は、発生したら関数が最後まで終わるのを待たずに強制終了して、\n例外を捕まえるまで関数呼び出し元をたどっていってスタックをロールバックして…\nといった、いわゆる大域ジャンプを伴う、プログラムの特殊なフローのことです。\nここでは例外の使い方についてまとめます。\n\nSource: $(LINK_TO_SRC source/_exception_example.d)\nMacros:\n    TITLE=例外処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L43_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 従来の方法とその欠点\n\n従来の例外機構のない言語では、関数の戻り値をチェックするのが一般的でした。\nしかし、戻り値のチェックは、以下のような欠点を抱えていました。\n\n1.  戻り値が無視されがち\n    戻り値でエラーが発生したことを伝えても、その戻り値が無視されてしまった場合、\n    失敗しても何事もなかったかのように処理が継続してしまいます。\n2.  プログラムの流れが汚れがち\n    たとえif文でエラーチェックをしても、同じ関数内で2回3回とチェックをするうち、\n    ネストが深くなったり、gotoで関数末尾のエラー処理部へジャンプしたり、\n    エラー処理のための本来行うべき処理とは関係の浅いフラグ変数が生じたりと、\n    プログラムが汚くなる場合が多く存在しました。\n3.  エラー処理分散しがち\n    同じエラーに対処しているはずなのに、呼び出した関数すべてにエラー処理を仕込む\n    必要があったり、様々なエラーをまとめて処理するのが難しい場合がありました。\n4.  nullを参照してしまう問題\n    1の場合とかぶりますが、nullが返る可能性のあるものでチェックを省くと、所謂\n    ぬるぽ(Null Pointer Exception)や、AV(Access Violation)、\n    SEGV(セグフォ/Segmentation Fault/Segmentation Violation)が発生します。\n    ぬるぽが一昔前にネットスラングにまでなったように、プログラムのユーザーが目に\n    する深刻な問題になりやすい異常です。しっかりガッ(対処)する必要がありますが、\n    プログラムの本来の処理に手一杯になると対処を怠ってしまうことも。\n\n以下に挙げる例は例外を使用しない場合の問題になりやすい記述方法です。\n",
    "line" : 43,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 211,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L211_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 例外のメリット\n\n例外機構を用いるメリットは、明示しない限り例外が無視されず、例外処理に対応する\n箇所をまとめて記述することができるため、本来のプログラムに集中した記述ができる\nという点です。\n\n以下の例は、先述の戻り値のチェックで問題になりやすいものを、例外を使用して解決\nする場合を示したものです。\n",
    "line" : 211,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 330,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L330_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# デメリットと使用を避けるべき時の判断基準\n\nデメリットとしては、例外が発生するとプログラムを途中で切り上げてスタックの\n巻戻し処理が行われるといったことが起こるため、処理速度は遅いことが挙げられます。\nこのため、適切な箇所でのみ例外機構を利用しましょう。\n具体的には以下のようなケースでは、例外機構を用いるより、if文による事前チェックや\n戻り値のチェック、表明(assert)や契約プログラミング(in/out/invariant)が望ましい\nでしょう。\n\n1.  秒間何千何万と繰り返し実行されるような処理の中で例外を発生させたり捕まえたり\n    をするのは止めておくのがよいでしょう。\n2.  事前のチェックを行うことで容易かつ高速に異常発生を防ぐことができるものは、\n    チェックしましょう。\n    (例外発生の頻度が著しく低い場合や、チェックが重い場合はとりあえずトライした\n    方が速いかも)\n3.  外的要因が絡まない場合はassertや、事前条件で代用できるかもしれません。\n    外的要因というのは、プログラムの利用者が作成したファイルや、ネットワーク越し\n    に渡されるパラメータ、GUIやCUIで入力した値、コマンドライン引数、ハードウェア\n    の状態に依存するようなものなどです。\n    例えばプログラム自身で作成したファイルを読み込む場合、文法チェック等は\n    assertによるチェックが望ましいかもしれません。\n4.  ほかの言語の関数呼び出しを行う場合、他言語間での例外のやり取りはできません。\n    これは、OSのAPIやシステムコール、C言語の標準関数を使用する場合も同様です。\n\n以下に挙げる例はあえて例外を使用しない方がよい場合の典型的な処理です。\n",
    "line" : 330,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 409,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L409_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# try-catch\n\n基本的な文法は `try {} catch(Exception e){}` です。\ntryの中(呼び出した関数を含め)で例外が発生した場合、catchで例外を捕捉できます。\nExceptionと記載しましたが、ここには例外の型を記載でき、よりマッチする条件の型\nから順番に記載することで、適切な対処を行うことが可能です。\n",
    "line" : 409,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 456,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L456_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# try-catch-finally\nJava等と同じように、finallyブロックが利用できます。\nしかし、D言語ではメジャーな機能ではありません。これと同等のことを行いたい場合は`scope (exit)`を使用することが多いです。\n",
    "line" : 456,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 509,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L509_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# スコープガード文： `scope (success)` / `scope (failure)` / `scope (exit)`\nスコープガード文です。try-catch-finallyの代わりに利用できます。\nそれぞれ以下の文が利用できます。\n- `scope (success)`は成功した(例外が発生しなかった)ときだけ実行されるブロックです\n- `scope (failure)`は失敗した(例外が発生した)ときだけ実行されるブロックです\n- `scope (exit)`は成否にかかわらず(例外が発生有無にかかわらず)_必ず_実行されるブロックです\n\n特に `scope (exit)` は、リソースの確保と解放のコードを近くに記載することができるのが便利です。\n",
    "line" : 509,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 574,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L574_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 例外とエラー\nD言語では、修復可能な問題を例外と呼び、ExceptionやExceptionを継承したクラスのオブジェクトをthrowすることによって発生させます。\n一方で、修復不可能な問題の場合はエラーといって、ErrorやErrorを継承したクラスのオブジェクトをthrowします。\n基本的にはErrorは修復不可能であるため、catchする必要はありません。\nExceptionもErrorもThrowableというインターフェースを継承しているので、ExceptionもErrorもcatchしたいという場合はThrowableをcatchすることができます(が、推奨されません)。\n\nなお、safeコードの中では、ErrorやThrowableをcatchすることはできません。\n",
    "line" : 574,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 618,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L618_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# nothrow\n例外を投げない関数はnothrowをつけることができます。\nただし、nothrowとついていても、Errorは投げることができるので注意が必要です。\n",
    "line" : 618,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 656,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L656_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 例外の自作\n例外クラスはExceptionを継承したクラスを自分で定義することができます。\n\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#basicExceptionCtors\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 656,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 718,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L718_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# エラー時に例外を投げる便利関数 [std.exception.enforce]\nもしエラーだったら例外を投げる…というユースケースを簡単にしたい場合は、enforceが便利です。\n\n```d\nauto res = foo();\nif (!res)\n    throw new Exception(\"hogehoge\");\n```\nを、\n```d\nauto res = enforce(foo(), \"hogehoge\");\n```\nと書くことのできる関数です。さらに、UFCSを使うと `auto res = foo().enforce(\"hogehoge\");` と書くこともできます。\n\nエラーかどうかを関数の戻り値などで判定するケースは多いですが、いちいちめったに起こらない例外のために\n`if (!res) throw new Exception(....)`\n等と書くと本流のロジックが分断され読みづらいからあんまり書きたくないし、もし例外が起こったら呼び出し側の関数に対処してほしい…という場合に使います。\n\n特に例外を使わずに戻り値でエラーコードの通知を行うC言語のプログラムや、Nullが帰る可能性のある関数、ダイナミックキャストの結果などで使用します。\n\n使い方は、1個目の引数にtrueに判定されることを期待しているもの、2個目の引数にfalseに判定された時の例外メッセージを指定します。メッセージは省略可能です。\nおおむね `assert()` と同じです。\n\n`assert()` は、「絶対こうなるはず。こうならなきゃおかしい。」という場合に使って、\n`enforce()` は、「うまくいけばこうなるはず。こうならなきゃ私の手に負えない何らかの例外が起こっている。」という場合に使います。\n\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#enforce\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 718,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 773,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L773_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 発生した例外を取得する便利関数 [std.exception.collectException]\n\nもし呼び出した関数で例外が発生する可能性がある場合で、その場で例外に対処できる場合、collectExceptionが便利です。\n\n```d\ntry\n{\n    foo();\n}\ncatch (Exception e)\n{\n    // エラー処理\n}\n```\nを、\n```d\nif (auto e = collectException(foo()))\n{\n    // エラー処理\n}\n```\nと書くことのできる関数です。\n\n1つの関数呼び出しのためにtry-catch構文を使うと読みづらくなりそうな場合や、\n例外に対して何もしなくてよい時に握りつぶしたい場合、\n例外が発生する可能性が高く、例外に対処するためのプログラムを書く場合などに、ロジックを整理しやすくすることができます。\n\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#collectException\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 773,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 790,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L790_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 例外発生時にデフォルト値を返すようにする便利関数 [std.exception.ifThrown]\n\nもしかしたら例外が発生するかもしれない場合に、例外が発生した際の代替値を指定するために使用します。\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#ifThrown\n",
    "line" : 790,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 832,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L832_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 例外が起きることをテストする便利関数 [std.exception.assertThrown / std.exception.assertNotThrown]\nこの関数をこの条件で呼び出すと必ず例外を発生させるはずだ、という状況をテストで検証する場合、通常ならば以下のようにcatchしてassert文で検証します。\n\n```d\nbool exthrown;\ntry\n{\n    auto num = \"hogehoge\".to!int();\n}\ncatch (ConvException e)\n{\n    exthrown = true;\n}\nassert(exthrown, \"hogehoge is not a number, but exception is not caught.\");\n```\n\n毎回これをやるのは手間なので、 assertThrown や assertNotThrown を使って楽をすることができます。\nassertThrown や assertNotThrownは、例外の型をテンプレート引数で指定することもできます。\n(指定しなければExceptionがキャッチされるかどうかを確認します)\n\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#assertThrown\n    - https://dlang.org/phobos/std_exception.html#assertNotThrown\n\n",
    "line" : 832,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 853,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L853_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# Range操作中の例外発生要素のハンドリングをする便利関数 [std.exception.handle]\n\nRangeを使用した処理では、mapなど要素一つ一つに対して処理を行うような操作が多いですが、要素に対する操作中例外が発生することも少なくありません。\nhandle関数では要素の操作中に例外が発生した場合に、その例外への対処を行うことができます。ifThrownのRange版のような関数です。\n\nSee_Also:\n    - https://dlang.org/phobos/std_exception.html#handle\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 853,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 873,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "file_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/file_example.d",
  "comment" : "ファイルシステム\n\nファイル・パス操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_file_example.d)\nMacros:\n    TITLE=ファイルとパス操作の例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "テキストファイル操作の例です。\n",
    "line" : 15,
    "char" : 1,
    "endline" : 55,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L55_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ディレクトリ操作の例です。\n",
    "line" : 55,
    "char" : 1,
    "endline" : 102,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L102_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "基本的なパスに操作の例です。\n\n`baseName` 関数でファイル名の取得、`dirName` 関数でディレクトリパスを取得します。\n",
    "line" : 102,
    "char" : 1,
    "endline" : 122,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L122_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ファイルパスの拡張子を操作する例です。\n\n取得、変更、取り除く、といった操作ができます。\n",
    "line" : 122,
    "char" : 1,
    "endline" : 154,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L154_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ファイル移動の例です。\n\n`rename` を使い、ファイル名はそのままでディレクトリパスを変更することで移動が実現できます。\n",
    "line" : 154,
    "char" : 1,
    "endline" : 186,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L186_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ディレクトリ内のファイル一覧のうち、パターンに合致するものだけを列挙する例です。\n\n`dirEntries` に対して対象とするファイル名の glob パターンを指定します。\n\nSee_Also: https://dlang.org/phobos/std_file.html#dirEntries\nSee_Also: https://dlang.org/phobos/std_path.html#.globMatch\n",
    "line" : 186,
    "char" : 1,
    "endline" : 266,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L266_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ディレクトリ階層をまとめて作成および削除する例です\n",
    "line" : 266,
    "char" : 1,
    "endline" : 284,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L284_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ディレクトリに含まれるファイルを別のディレクトリへ移動、コピーする例です。\nこの例では階層構造を考慮せず、ディレクトリ直下のファイルのみを処理します。\n",
    "line" : 284,
    "char" : 1,
    "endline" : 323,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "gc_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/gc_example.d",
  "comment" : "ガベージコレクション\n\nガベージコレクション(GC)の制御についてまとめます。\n\nSource: $(LINK_TO_SRC source/_gc_example.d)\n",
  "members" : [
   {
    "name" : "__unittest_L18_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "GCの有効化・無効化を行う例です。\n\nD言語のGCは、現状では保守的なマーク＆スイープ型GCとなっています。\nGCによるスキャンおよびメモリ回収は、動的メモリの要求が行われた時のみ実行されます。\n事前にGC.disableを呼び出しておくことで、自動的なGCの実行を抑制することができます。\nただし、不要メモリの回収が行われなくなることで、メモリ不足のエラー(Out of memory)が発生する可能性も高くなります。\n",
    "line" : 18,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 43,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L43_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "明示的にGCを行う例です。\n\n大量のオブジェクトの利用が終了した後に呼び出す、\nGCを避けたい処理の前に呼び出しておく、等の用途が考えられます。\n",
    "line" : 43,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 68,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L68_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "GCが確保しているメモリをOSに返却して最小化する例です。\n\nGC.minimizeにより、GCが確保している未使用の物理メモリをOSに返却することができます。\n",
    "line" : 68,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 119,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L119_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Dの実行ファイルでは、 GC関連のパラメーターを\nコマンドラインオプション--DRT-gcoptまたは環境変数DRT_GCOPTにより設定できます。\n\nExamples:\n----\n# --DRT-gcoptパラメーターによる指定\n$ app \"--DRT-gcopt=profile:1 minPoolSize:16\" arguments to app\n\n# 環境変数による指定\n$ DRT_GCOPT=\"profile:1 minPoolSize:16\" app arguments to app\n----\n\nGC関連パラメーターの一覧は以下で定義されています。\nhttps://dlang.org/spec/garbage.html#gc_config\n\nまた、実行ファイルで--DRT-gcopt=helpパラメーターを指定して起動すると、\n現在の設定内容とデフォルト値を確認できます。\n\nExamples:\n----\n$ app --DRT-gcopt=help arguments to app\n----\n\n--DRT-gcoptパラメーターは、Dのmain関数の引数からは除外されます。\n元々のコマンドラインパラメーターは、 rt.configモジュールの\nrt_argsから参照することができます。\n\n--DRTのパラメーターは、ソースコード内でrt_optionsグローバル変数を定義する事によって\nデフォルト値を指定することが可能です。\n",
    "line" : 119,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 167,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "getopt_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/getopt_example.d",
  "comment" : "コマンドライン解析\n\n`std.getopt` の使い方についてまとめます。\n\n実行プログラムの引数を解析することができ、柔軟なプログラム作成を助けます。\n\nSource: $(LINK_TO_SRC source/_getopt_example.d)\nMacros:\n    TITLE=コマンドライン引数の解析例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "基本的な引数解析の例です\n",
    "line" : 17,
    "char" : 1,
    "endline" : 46,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L46_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "適度な折り返しを入れてコードフォーマッターでも可読性を保つ例です。\n",
    "line" : 46,
    "char" : 1,
    "endline" : 73,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "hash_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/hash_example.d",
  "comment" : "ハッシュ値の計算\n\n`std.digest` の使い方についてまとめます。\n\n文字列やバイナリデータに対してハッシュ値（ダイジェスト、チェックサムとも呼ばれる）を求めたり16進数の文字列に変換する手順を整理します。\n\nSource: $(LINK_TO_SRC source/_hash_example.d)\n",
  "members" : [
   {
    "name" : "__unittest_L19_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "様々なデータから `ubyte[N]` なハッシュ値を計算する方法\n\nアルゴリズム毎に提供される便利関数や `digest` 関数を使います。\nなおアルゴリズムによって生成されるハッシュ値のサイズは決まっているため、これに応じて戻り値の型も変わります。\n",
    "line" : 19,
    "char" : 1,
    "endline" : 58,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L58_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "求めたハッシュ値(ubyteの静的配列、バイト列)から16進数の文字列(`string`)を取得する方法\n\n`toHexString` を利用します。\nその他 `format` を使って整形する例については文字列のサンプルを参照してください。\n\n`toHexString` : $(LINK https://dlang.org/phobos/std_digest.html#.toHexString)\n",
    "line" : 58,
    "char" : 1,
    "endline" : 84,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "is_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/is_example.d",
  "comment" : "is式\n\nis式についてまとめます。\n\nSource: $(LINK_TO_SRC source/_is_example.d)\nMacros:\n    TITLE=is式を使って様々な判定をする例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 正当性の検証\n",
    "line" : 15,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 63,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L63_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 暗黙の型変換可能かどうかの検証\n",
    "line" : 63,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 109,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L109_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 型の分類\n",
    "line" : 109,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 220,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "meta_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/meta_example.d",
  "comment" : "メタプログラミング\n\nメタプログラミングに出てくるイディオム等についてまとめます。\n\nSource: $(LINK_TO_SRC source/_meta_example.d)\nMacros:\n    TITLE=メタプログラミングおよび頻出イディオムの例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "モジュールの定義一覧を取得する例です。\n\n`__traits(allMembers, モジュール名)`と書きます。\n",
    "line" : 17,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 31,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L31_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "任意のモジュール名から定義一覧を取得するイディオムです。\n\nモジュールの参照を`mixin`と`std.meta.Alias`を使って取得します。\n",
    "line" : 31,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 60,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L60_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "実際にコンパイルできるかどうか確認するイディオムです。\n\nD言語のコード片が実際にコンパイルできる場合にはtrueに、そうでない場合はfalseに評価されます。\nこの強力なイディオムのやり方は2種類あって、`is(typeof(...))`を使用する方法と、`__traits(compiles, ...)`を使用する方法があります。\nどちらでも効果はほぼ同じですが、やや`is(typeof(...))`のほうがチェックが緩いです。過去dmdへ多大な貢献をされた[9rnsrさんの記事](https://qiita.com/9rnsr/items/5e3e434ea8719fbeea82)で解説されています。\n\nなお、このイディオムはきわめて強力な一方、実際にコンパイルできるかどうか、コンパイラが実際にコンパイルを試行して確かめる必要があるため、コンパイル速度的にはやや不利です。\nそのためかどうなのか、std.rangeのisInputRangeなどは、[過去この方法で実装されていた](https://github.com/dlang/phobos/blob/c4f1c43366c79f4ff9ddfadbc0a8c943e0cb5c94/std/range.d#L528)こともありますが、[今は違います](https://github.com/dlang/phobos/blob/d29ebfe6ec0fd3879513e0f8a533b234f3d101e1/std/range/primitives.d#L171)。\n",
    "line" : 60,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 111,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L111_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "一度特殊化されたテンプレートの型から、特殊化前のテンプレートと引数を取得する例です。\n",
    "line" : 111,
    "char" : 1,
    "endline" : 138,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L138_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ある型が、特定のテンプレートを特殊化したものかどうかを判定する例です。\n",
    "line" : 138,
    "char" : 1,
    "endline" : 163,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L163_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "関数が右辺値/左辺値で呼ぶことができるか確認する方法\n",
    "line" : 163,
    "char" : 1,
    "endline" : 188,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L188_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "要素の型を得る\n\nElementTypeがそれっぽく見えるが、実はForeachTypeのほうが扱いやすい。\nSee_Also:\n    - https://dlang.org/phobos/std_range_primitives.html#ElementType\n    - https://dlang.org/phobos/std_traits.html#ForeachType\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 188,
    "char" : 1,
    "endline" : 244,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "network_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/network_example.d",
  "comment" : "ネットワーク(cURL)\n\nネットワークモジュール、特に `std.net.curl` の使い方についてまとめます。\n\nHTTP通信などができます。\n\nSource: $(LINK_TO_SRC source/_network_example.d)\nMacros:\n    TITLE=cURLを使ったネットワーク処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "HTTPでGET\n",
    "line" : 17,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 67,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L67_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "独自のHeaderを付けてGETリクエストを送る方法\n\n外部APIを呼ぶ場合など、AuthorizationヘッダーでBearerトークンを渡す例です。\n",
    "line" : 67,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 90,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L90_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "www-form-urlencoding 形式でデータをPOSTする方法\n",
    "line" : 90,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 116,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L116_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "JSON 形式のデータをPOSTする方法\n",
    "line" : 116,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 151,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L151_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字コードの話\n",
    "line" : 151,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 195,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L195_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "認証付きProxyを通す\n",
    "line" : 195,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 232,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L232_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "クライアント認証する\n\nCurlOption.sslcertなどのオプションを使用します。\n\n-  WindowsではDMDやLDCにOpenSSLがリンクされていないlibcurl.dllが使われているようですが\n   クライアント認証にはOpenSSLが必要となりますので、OpenSSLがリンクされたlibcurl.dllを使用する必要があります。$(BR)\n-  さらに、cURLの公式で配布している64bitのDLLは libcurl-x64.dll という名称ですが、`std.net.curl`が使用するDLLの名称は`libcurl.dll`または`curl.dll`固定です。\n   このため、ファイル名を変更する必要があります。\n-  また、OpenSSLのDLL`libcrypto-1_1-x64.dll`、`libssl-1_1-x64.dll`なども用意します。\n\nなお、CA証明書、クライアント証明書や秘密鍵の生成方法・変換方法はここでは解説いたしません。\n",
    "line" : 232,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 287,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "numeric_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/numeric_example.d",
  "comment" : "数値計算\n\n標準ライブラリで提供される数値計算の関数などについてまとめます。\n\n主に `std.math` や `std.mathspecial`、 `std.numeric` を使った例を対象とします。\n\nSource: $(LINK_TO_SRC source/_numeric_example.d)\nMacros:\n    TITLE=数値計算でよく利用される関数などの使用例\n",
  "members" : [
   {
    "name" : "__unittest_L23_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "浮動小数点数の同値判定の例です。\n\n浮動小数点数は計算の過程で誤差が出るため、相対誤差や絶対誤差を考慮して比較します。\n\n`std.math` の `isClose` を利用します。\n\nstd.math.isClose : $(LINK https://dlang.org/phobos/std_math.html#.isClose)$(BR)\n",
    "line" : 23,
    "char" : 1,
    "endline" : 42,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L42_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "内積を計算する例です。\n\n`std.numeric` の `dotProduct` を利用します。\n",
    "line" : 42,
    "char" : 1,
    "endline" : 58,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L58_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "コサイン類似度を計算する例です。\n\n2つのレンジを受け取って、その類似度を0-1で返します。\n",
    "line" : 58,
    "char" : 1,
    "endline" : 79,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L79_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "標準正規分布の累積分布関数とその逆関数を計算する例です。\n\nそれぞれ `std.mathspecial` モジュールの `normalDistribution` と `normalDistributionInverse` という関数で提供されます。\n\n正規分布 : $(LINK https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E5%88%86%E5%B8%83)\n\n累積分布関数 : $(LINK https://ja.wikipedia.org/wiki/%E7%B4%AF%E7%A9%8D%E5%88%86%E5%B8%83%E9%96%A2%E6%95%B0)\n",
    "line" : 79,
    "char" : 1,
    "endline" : 96,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "opovl_excample",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/opovl_excample.d",
  "comment" : "演算子オーバーロード\n\nD言語では演算子オーバーロードを定義することができます。\n\n例えばstd.bigintでは、BigIntに対して、整数型のような特徴を持たせるため、四則演算などの演算子オーバーロードを実装しています。\n\nD言語では、演算子オーバーロードを定義する際には、もともとの演算子の意味を損なうような利用方法は非推奨としています。\n例えばC++であるように、`std::cout << hogehoge << std::endl;`のような、ビットシフトのための演算子`<<`をストリーム操作のために使用するような利用方法は非推奨です。\n\nSee_Also:\n    - https://dlang.org/spec/operatoroverloading.html\n    - https://dlang.org/dstyle.html#operator_overloading\n\nSource: $(LINK_TO_SRC source/_opovl_excample.d)\nMacros:\n    TITLE=演算子オーバーロードの例\n",
  "members" : [
   {
    "name" : "__unittest_L24_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "演算子オーバーロードの活用例: BigInt\n",
    "line" : 24,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 50,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L50_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "opBinary: 二項演算子のオーバーロード\n\n先述のBigIntに代表されるように、組み込み型以外のユーザー定義型であっても、組み込み型と似た特徴を持つ(同じように演算子が使える)ようにすることができるのが、演算子オーバーロードです。\nここでは代表例として、opBinaryという、二項演算子全般をオーバーロードする方法を使って、四則演算できるようにします。\nopBinaryはテンプレートのメンバー関数として定義します。これを定義すると、足し算や引き算等二項演算子を使用した際、テンプレート引数に使用された二項演算子の演算子が渡されます。\n\nopBinaryは二項演算子であればよいので、+, -, *, / 以外にも、 ~ や & 等の演算子でも利用できます。\n\nSee_Also:\n    - https://dlang.org/spec/operatoroverloading.html#binary\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 50,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 102,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L102_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "opUnary: 単項演算子のオーバーロード\n\n` auto b = -a; ` の `-a` (プラスマイナスの符号を逆転する)のように、単項に対する演算子があります。\nたとえば、`-`に加えて'+'、`*`(ポインタ外し), `~`(ビット反転), `!`(否定), `++`(インクリメント), `--`(デクリメント)が相当します。\n\nSee_Also:\n    - https://dlang.org/spec/operatoroverloading.html#unary\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 102,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 117,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "parallelism_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/parallelism_example.d",
  "comment" : "並列処理\n\n`std.parallelism` を使った並列処理の例をまとめます。\n\nSource: $(LINK_TO_SRC source/_parallelism_example.d)\nMacros:\n    TITLE=並列処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "配列データなどを元に、値毎の処理を並列で行い高速化する例です。\n\nこれは「データ並列」と呼ばれ、 `parallel` 関数を使うことで簡単に行えます。\n",
    "line" : 17,
    "char" : 1,
    "endline" : 41,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L41_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "`parallel` で実行する処理で一部同期が必要となる場合の例です。\n\nいくつか実現方法はありますが、ここでは組み込みの `synchronized` 文を使い、複数のスレッドが同時に処理できない区間（クリティカルセクション）を定義します。\nこれは排他処理とも呼ばれます。\n",
    "line" : 41,
    "char" : 1,
    "endline" : 73,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L73_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "並列処理の基本となる `task` の使い方をまとめます。\n\nこれは何らかの「処理」を抽象化したオブジェクトであり、指定した処理を別スレッドで処理させることができます。\n\n- 新しくスレッドを起動して実行する\n- TaskPoolとして用意しておいたスレッドで実行する\n\n以下は、処理を定義して新しいスレッドで実行、完了を待機する例です。\n",
    "line" : 73,
    "char" : 1,
    "endline" : 102,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L102_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ランタイムが用意したスレッドを使って `task` を実行する例です。\n\n実行の際に `taskPool` を使うことでスレッドを使いまわし、実行の度に新しくスレッドを起動するコストが削減できます。\n\n処理の実行は、`taskPool` に `task` を `put` することにより行えます。\n\nなお、`taskPool` が起動するスレッド数は環境によって異なり、`CPU数 - 1` として計算されます。\nこの `CPU数` は `totalCPUs` という定数によって得ることができます。\n",
    "line" : 102,
    "char" : 1,
    "endline" : 133,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L133_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "戻り値を持つ `task` の使用例です。\n\n`task` で実行する処理は戻り値を持つことができ、処理の結果は `yieldForce` の戻り値として得られます。\n\nこれを `executeInNewThread` と組み合わせると、簡便な「戻り値を持つスレッド」として使うことができます。\n",
    "line" : 133,
    "char" : 1,
    "endline" : 158,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L158_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "スレッド数を指定した独自の TaskPool を作る例です。\n\n処理が通信などCPUを使わない処理を含む場合、CPUより多くのスレッドを起動しておくことで処理の高速化が期待できます。\n",
    "line" : 158,
    "char" : 1,
    "endline" : 196,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "process_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/process_example.d",
  "comment" : "プロセス\n\nプロセス操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_process_example.d)\nMacros:\n    TITLE=プロセス操作の例\n",
  "members" : [
   {
    "name" : "__unittest_L17_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "基本的なプロセス起動を行う操作の例です。\n",
    "line" : 17,
    "char" : 1,
    "endline" : 42,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L42_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "パイプでコマンドをつなげる例です。\n",
    "line" : 42,
    "char" : 1,
    "endline" : 114,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L114_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "WindowsのGUIからのコンソールアプリケーション呼び出しのときにコンソール画面を出さないようにする。\n\nWindows特有の問題になりますが、GUIアプリケーションでビルドした場合、executeやspawnProcess等を実行してコンソールアプリケーションを起動すると、実行中のコンソール画面が表示されてしまうということがあります。\nこれを抑止するため、実行時に `Config.suppressConsole` を指定することで、コンソール画面の表示を行わないようにすることができます。\n\nSee_Also: https://dlang.org/phobos/std_process.html#.Config.suppressConsole\n",
    "line" : 114,
    "char" : 1,
    "endline" : 147,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L147_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "たくさんパイプしながら、データを小分けにして渡していく場合\n",
    "line" : 147,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 241,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L241_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "標準出力をファイルにリダイレクトする例です\n",
    "line" : 241,
    "char" : 1,
    "endline" : 267,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L267_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "環境変数を扱う例です。\n",
    "line" : 267,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 295,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "random_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/random_example.d",
  "comment" : "乱数\n\n乱数操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_random_example.d)\nMacros:\n    TITLE=乱数操作の例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "基本的な乱数を生成する例です。\n",
    "line" : 15,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 46,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L46_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "配列を乱数で初期化する例です。\n",
    "line" : 46,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 66,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L66_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "シミュレーション用途など、再現可能な乱数を作るためにシードを指定する例です。\n\n実行時に毎回異なるシードを使う場合は、 unpredictableSeed を使用します。\n",
    "line" : 66,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 103,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L103_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "標準正規分布に基づく乱数を生成する例です。\n\nstd.mathspecial にある normalDistributionInverse を使うことで確率変数から逆変換できます。\n\n`normalDistributionInverse` : $(LINK https://dlang.org/phobos/std_mathspecial.html#normalDistributionInverse)\n",
    "line" : 103,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 112,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "range_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/range_example.d",
  "comment" : "レンジ\n\nレンジの操作についてまとめます。\n\n## レンジ(Range)とは\n\nレンジ(Range)とは、配列やリストといった要素を順次アクセスできるものを一般化した概念です。\n\nD言語では、データ構造やアルゴリズムをレンジの仕様に合わせて実装することで、さまざまなメリットが得られます。\n\n* レンジの仕様に合ったデータ構造であれば、`std.algorithm`などの既存ライブラリのアルゴリズムをそのまま適用できます。\n* レンジを扱えるようアルゴリズムや関数を実装することで、配列や`std.container`などの既存のデータ構造に対してそのまま使用できます。\n* レンジの概念はD言語プログラマーの間に広く浸透しています。\n  そのため、自作のデータ構造や関数をレンジの仕様に合わせてあれば、他のD言語プログラマーにも使い方がすぐに伝わります。\n\n## 参考\n\n* `std.range` : https://dlang.org/phobos/std_range.html\n* `std.algorithm` : https://dlang.org/phobos/std_algorithm.html\n\nTODO:\n* 配列・文字列をレンジとして利用する。\n* レンジの種類の紹介\n* std.rangeの各関数の紹介\n\n\nSource: $(LINK_TO_SRC source/_range_example.d)\nMacros:\n    TITLE=レンジを扱う処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L37_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "最小のレンジ(InputRange)を作る\n",
    "line" : 37,
    "char" : 1,
    "endline" : 149,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L149_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "連番のレンジを作る`iota`の例です。\n",
    "line" : 149,
    "char" : 1,
    "endline" : 167,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L167_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "引数に指定した要素だけのレンジを作る`only`の例です。\n",
    "line" : 167,
    "char" : 1,
    "endline" : 187,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L187_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "引数に指定した要素を無限に繰り返す`repeat`の例です。\n",
    "line" : 187,
    "char" : 1,
    "endline" : 212,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L212_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "指定された関数を使ってレンジを生成する`generate`の例です。\n",
    "line" : 212,
    "char" : 1,
    "endline" : 235,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L235_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "漸化式のレンジを生成する`recurrence`の例です。\n",
    "line" : 235,
    "char" : 1,
    "endline" : 269,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L269_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "動的配列とRangeのどちらにも使用できる関数を定義する例です。\n",
    "line" : 269,
    "char" : 1,
    "endline" : 335,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "regex_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/regex_example.d",
  "comment" : "正規表現\n\n正規表現の操作についてまとめます。\n\nSource: $(LINK_TO_SRC source/_regex_example.d)\nMacros:\n    TITLE=正規表現の例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 正規表現オブジェクトの生成\n",
    "line" : 15,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 29,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L29_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 正規表現用の文字列\n",
    "line" : 29,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 68,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L68_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 部分文字列の検索\n",
    "line" : 68,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 77,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L77_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 部分文字列の検索 (matchFirst)\n",
    "line" : 77,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 146,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L146_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "## 部分文字列の検索 (matchAll)\n",
    "line" : 146,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 193,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L193_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 文字列の置換\n",
    "line" : 193,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 216,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L216_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 文字列の分割\n",
    "line" : 216,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 233,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L233_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# Unicodeプロパティ\n",
    "line" : 233,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 245,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L245_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "# 先読み・後読み\n",
    "line" : 245,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 321,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "string_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/string_example.d",
  "comment" : "文字列\n\n文字列操作についてまとめます。\n\nTODO: 置換(replace), 削除(remove), 分割(split)\n\nSource: $(LINK_TO_SRC source/_string_example.d)\nMacros:\n    TITLE=文字列操作の例\n",
  "members" : [
   {
    "name" : "__unittest_L39_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "D言語の文字列の種類\n\nD言語の文字列は、基本的に文字の配列で、特別な型やクラスがあるわけではありません。ただし、文字型はchar(UTF-8), wchar(UTF-16), dchar(UTF-32)があり、それぞれ修飾子がありますので、種類は多いです。\nまた、UTF-8, UTF-16, UTF-32 以外の文字コードは「バイト列(符号なし8bit整数の配列)」という扱いです。ただし、一部のライブラリや、C言語との受け渡しインターフェースなどには便宜上char型を使うことがあります。\n\n| 型修飾               | UTF-8                      | UTF-16                      | UTF-32                      | それ以外                    |\n|:--------------------:|:--------------------------:|:---------------------------:|:---------------------------:|:---------------------------:|\n| (none)               | char[]                     | wchar[]                     | dchar[]                     | ubyte[]                     |\n| const型              | const(char)[]              | const(wchar)[]              | const(dchar)[]              | const(ubyte)[]              |\n| inout型              | inout(char)[]              | inout(wchar)[]              | inout(dchar)[]              | inout(ubyte)[]              |\n| shared型             | shared(char)[]             | shared(wchar)[]             | shared(dchar)[]             | shared(ubyte)[]             |\n| const shared型       | const shared(char)[]       | const shared(wchar)[]       | const shared(dchar)[]       | const shared(ubyte)[]       |\n| inout shared型       | inout shared(char)[]       | inout shared(wchar)[]       | inout shared(dchar)[]       | inout shared(ubyte)[]       |\n| const inout型        | const inout(char)[]        | const inout(wchar)[]        | const inout(dchar)[]        | const inout(ubyte)[]        |\n| const inout shared型 | const inout(shared char)[] | const inout shared(wchar)[] | const inout shared(dchar)[] | const inout shared(ubyte)[] |\n| immutable型          | immutable(char)[]          | immutable(wchar)[]          | immutable(dchar)[]          | immutable(ubyte)[]          |\n\nこの中でも、特に利用頻度が高いのが`immutable(char)[]`型で、これは文字列リテラルの型であり、特別に`string`という別名が利用できます。\n同様に、`immutable(wchar)[]`には`wstring`という別名が、`immutable(dchar)[]`には`dstring`という別名が、それぞれ利用できます。\n\nimmutableはマルチスレッド間でクリティカルセクションなしに同時アクセスできたり、寿命を考えなくてもよい点、const型への暗黙変換ができる点などが便利です。\n\n以下のサンプルでは文字コード(UTF-8, UTF-16, UTF-32)のそれぞれの変換について説明します\n",
    "line" : 39,
    "char" : 1,
    "endline" : 92,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L92_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列型の使い分け\n\n文字列の型は、おおむね次のような使い分けをします。\n\n- 普段使いは`string`\n- 関数引数で、関数が終わった後はメモリが破壊されてもいいなら`const(char)[]`\n- 関数引数で、関数が終わった後にメモリが破壊されて困るなら`string`\n- 1文字が1要素であってほしい場合は`dchar[]`や`dstring`\n- N文字目を書き換えたい場合は`dchar[]`\n- Windows APIに渡すなら`wchar[]`や`const(wchar)[]`\n\nさらに、D言語では、スライスの型はありません。`string`のスライスは`string`だし、`const(char)[]`のスライスは`const(char)[]`です。\n",
    "line" : 92,
    "char" : 1,
    "endline" : 174,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L174_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列の連結➀\n\n文字列は単純な文字の配列なので、`~`演算子で連結できます。\n",
    "line" : 174,
    "char" : 1,
    "endline" : 216,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L216_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列の連結➁\n\n事前に長さの分からない文字列を構築する場合、`std.array` の `appender` を使います。\n\n`appender` : https://dlang.org/phobos/std_array.html#appender\n",
    "line" : 216,
    "char" : 1,
    "endline" : 238,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L238_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列の連結③\n\n数値などの様々な値を文字列化したうえで連結した結果を得るには、`std.conv` の `text` 関数を利用します。\n\n`text` : https://dlang.org/phobos/std_conv.html#text\n",
    "line" : 238,
    "char" : 1,
    "endline" : 262,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L262_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "書式化文字列\n\n`std.format` の `format` を使います。\n\nhttps://dlang.org/phobos/std_format.html#.format\n",
    "line" : 262,
    "char" : 1,
    "endline" : 278,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L278_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "完全一致、辞書順での比較\n",
    "line" : 278,
    "char" : 1,
    "endline" : 292,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L292_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "大文字小文字を無視して比較\n\n`std.uni` の `icmp` を使います\n\n`icmp` : https://dlang.org/phobos/std_uni.html#icmp\n",
    "line" : 292,
    "char" : 1,
    "endline" : 317,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L317_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "「で始まる」「で終わる」の例\n\n`std.algorithm` の `startsWith`, `endsWith` を使います。\n\n`startsWith` : $(LINK https://dlang.org/phobos/std_algorithm_searching.html#.startsWith)$(BR)\n`endsWith` : $(LINK https://dlang.org/phobos/std_algorithm_searching.html#.endsWith)\n",
    "line" : 317,
    "char" : 1,
    "endline" : 339,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L339_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列が出現する位置を検索します。\n\n`std.string` の `indexOf` を使用します。\n\n`indexOf` : https://dlang.org/phobos/std_string.html#.indexOf\n",
    "line" : 339,
    "char" : 1,
    "endline" : 380,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L380_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列の置換\n\n`std.array` の `replace` あるいは `replaceFirst`, `replaceLast`, `replaceInPlace`, `replaceInto` を使用します。\nただし、 `replace`, `replaceInPlace` に関しては `std.string` の中にもaliasがあるため、どちらからimportしてもよいです。\n\nそれぞれの違いは以下。\n\n| 置換関数 | 特徴 |\n|:--------:|:-----|\n| replace        | 第1引数の文字列(配列)の中の、第2引数に完全一致する **すべての** 部分を、第3引数の文字列(配列)で置き換えた新しい文字列を返します。 |\n| replaceFirst   | 第1引数の文字列(配列)の中の、第2引数に完全一致する **最初の** 部分を、第3引数の文字列(配列)で置き換えた新しい文字列を返します。 |\n| replaceLast    | 第1引数の文字列(配列)の中の、第2引数に完全一致する **最後の** 部分を、第3引数の文字列(配列)で置き換えた新しい文字列を返します。 |\n| replaceInto    | 第2引数の文字列(配列)の中の、第3引数に完全一致する **すべての** 部分を、第4引数の文字列(配列)で置き換えて **第1引数のOutputRangeにput** します。 |\n| replaceInPlace | 第1引数の文字列(配列)の中の、**第2引数～第3引数** までの部分を、第4引数の文字列(配列)で **上書きで置き換えて** 返します。 |\n\n`replace`, `replaceFirst`, `replaceLast` は元の文字列はそのままに、新しい文字列を作成します。これにはメモリ割り当てが発生します。\n\n`replaceInto` は、元の文字列はそのままに、新しい文字列を作成するというのは `replace` と同じですが、新しくできた文字列をOutputRangeの中に入れてくれるので、この関数の中で新しいメモリ割り当ては行われません。例えば数百MBある文字列を置換してファイルに書き出したい、とかのユースケースで役に立ちます。\n\n`replaceInPlace` は、元の文字列を上書きします。また、文字列の一致箇所という置換方法はできないため、第2引数と第3引数には `indexOf()` と文字列長を組み合わせて、添え字の範囲を指定する必要があります。$(BR)\n単に `text.replaceInPlace(text.indexOf(a), text.indexOf(a) + a.length, b)` は、 `text = text.replace(a, b)` と同じです。ただし、特殊な状況下(`dchar[]`を`dchar[]`で置換し、より短い文字列になる場合)では、メモリ割り当てが発生しません。\n",
    "line" : 380,
    "char" : 1,
    "endline" : 413,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L413_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "文字列の置換(正規表現)\n\n`std.regex` の `replaceAll`, `replaceFirst` を使用します。\nちなみに、以下のサンプルでは紹介しませんが、 `replace` に対する `replaceInto` と同様にOutputRange用の `replaceAllInto`, `replaceFirstInto` もあります。\n",
    "line" : 413,
    "char" : 1,
    "endline" : 436,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L436_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "プログラムの整形文字列表現\n\nchompPrefixやstrip、outdent、などを使うことで、プログラム言語などの文字列表現をいい感じに記載することができます。\n\nポイントはoutdentでインデントを解除することで、その前後にoutdentの入力にマッチするようにいい感じにchompPrefixで先頭の改行を削除したり、outdent結果を欲しい形に合うようにstripで先頭・末尾の改行を含む空白文字を削除するなどの前処理・後処理をします。\n\nパーサーを扱うようなプログラムなどで活躍します。\n\n`outdent`: https://dlang.org/phobos/std_string.html#.outdent$(BR)\n`chompPrefix`: https://dlang.org/phobos/std_string.html#.chompPrefix$(BR)\n`strip`: https://dlang.org/phobos/std_string.html#.strip\n",
    "line" : 436,
    "char" : 1,
    "endline" : 517,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L517_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "16進数文字列の変換\n\nバイト列を16進数の文字列で表現したものをバイト列に変換するのと、その逆を行います。\n\nSee_Also:\n    - https://dlang.org/phobos/std_conv.html#hexString\n    - https://dlang.org/phobos/std_conv.html#to\n    - https://dlang.org/phobos/std_range.html#chunks\n    - https://dlang.org/phobos/std_algorithm_iteration.html#.map\n    - https://dlang.org/phobos/std_array.html#.array\n    - https://dlang.org/phobos/std_format.html#.format\n    - https://dlang.org/phobos/std_digest.html#.toHexString\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 517,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 551,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "sumtype_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/sumtype_example.d",
  "comment" : "SumTypeの例\n\nSumTypeを使用すると、複数の型を複合した型を形成することができます。\nタグ付き共用体の1形態です。\n\nSee_Also:\n    - https://dlang.org/phobos/std_sumtype.html\nMacros:\n    TITLE=SumType（タグ付き共用体）の例\n",
  "members" : [
   {
    "name" : "__unittest_L28_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "SumTypeの初期化と値の取り出し方\n\n値の設定はコンストラクタか、代入によって行います。\n値の取り出しは、matchテンプレートを使用します。\n\nSee_Also:\n    - https://dlang.org/phobos/std_sumtype.html#.match\n    - https://dlang.org/phobos/std_sumtype.html#.SumType.this\n    - https://dlang.org/phobos/std_sumtype.html#.SumType.opAssign\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 28,
    "char" : 7,
    "storageClass" : [
     "@safe"
    ],
    "endline" : 50,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "sync_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/sync_example.d",
  "comment" : "同期機構/排他処理\n\nマルチスレッドで処理する場合、複数スレッドから同時に同じ変数を読み書きしないようにする必要があります。\nこれを適切に管理・実現するため、様々な同期処理が必要になる場合があります。\n\n手法については様々な物がありますが、ここではランタイムが持つ同期機構として以下について整理していきます。\n\n- 単独の `synchronized` 文\n- `Mutex`\n- `ReadWriteMutex`\n- `Barrier`\n- `Condition`\n- `Semaphore`\n- `Event`\n\nSource: $(LINK_TO_SRC source/_sync_example.d)\nMacros:\n    TITLE=同期処理と排他処理の例\n",
  "members" : [
   {
    "name" : "__unittest_L30_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "`synchronized` 文を用いて単独のクリティカルセクションを構成する例です。\n\n主に `std.parallelism` の `parallel` など、複数スレッドから1つの処理が同時に呼び出されるときに利用します。\n\nSee_Also: $(LINK https://dlang.org/spec/statement.html#synchronized-statement)\n",
    "line" : 30,
    "char" : 1,
    "endline" : 52,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L52_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "`Mutex` クラスを用いて複数のクリティカルセクションをグループ化し、同期させる例です。\n\nSee_Also: https://dlang.org/phobos/core_sync_mutex.html\n",
    "line" : 52,
    "char" : 1,
    "endline" : 95,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L95_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "`ReadWriteMutex` クラスを使い、書き込みと読み取りの排他を分けることで効率化する例です。\n\n読み取り同士では排他せず、読み取りと書き込み、書き込み同士のときに排他することで、\n単純な `Mutex` による排他よりもスループットが向上することが期待できます。\n\n|          | 読み取り | 書き込み |\n|:---------|:--------:|:--------:|\n| 読み取り | 排他なし | 排他あり |\n| 書き込み | 排他あり | 排他あり |\n\nSee_Also: $(LINK https://dlang.org/phobos/core_sync_rwmutex.html)\n",
    "line" : 95,
    "char" : 1,
    "endline" : 144,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L144_C1",
    "kind" : "function",
    "protection" : "public",
    "line" : 144,
    "char" : 1,
    "endline" : 165,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L165_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Barrierで、指定した数のスレッドが所定のポイントに達するまで待機する例です。\n\nSee_Also:\n    - https://dlang.org/phobos/core_sync_barrier.html\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 165,
    "char" : 1,
    "endline" : 206,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L206_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Conditionで、通知による同期を行う例です。\n\nConditionのコンストラクタに渡したMutexをロックしているときにwaitすると、そのMutexのロックを解除して待機状態に入ります。\nその後別スレッドがMutexをロックすると、notifyされても、Mutexがロック解除されるまでは待機を維持します。\n\n逆に、Conditionのコンストラクタに渡したMutexのロック解除中にwaitした場合、単にほかのスレッドからnotifyされるまで待機します。\n\n使用例として、Producer Consumerパターン内で、Guarded Suspensionパターンでの同期処理を行う場合に利用できます。\n- [解説サイト](https://www.hyuki.com/dp/dpinfo.html#ProducerConsumer)\n\nSee_Also:\n    - https://dlang.org/phobos/core_sync_condition.html\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 206,
    "char" : 1,
    "endline" : 272,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L272_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Semaphoreで、通知による同期を行う例です。\n\nConditionよりも単純で、Mutexとの関係を気にする必要はありません。\nSemaphoreは内部にカウント値を持っており、notifyでカウント値は+1されます。\nwaitではカウント値が0より大きくなるまで制御をブロックし、カウント値が0より大きくなったら制御を戻しつつカウント値を-1します。\n\n共有資源がある場合、通知する側はnotify以降の共有資源へのアクセス、通知される側はwait以前の共通資源へのアクセスについて、互いに競合しないよう排他する必要があります。\nSemaphoreでは通知する側はnotifyより前に共有資源の編集を終え、通知される側はwait以降に共有資源を使うようにすればよいでしょう。\n\nSee_Also:\n    - https://dlang.org/phobos/core_sync_semaphore.html\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 272,
    "char" : 1,
    "endline" : 313,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L313_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "Eventで、通知による同期を行う例です。\n\nConditionやSemaphoreよりも単純です。ただのフラグと考えればよいです。\nEventは内部にフラグを持っており、setでtrue(シグナル状態)に、resetでfalse(非シグナル状態)になります。\nwaitでは、フラグを見てfalseならtrueになるまで制御をブロックします。ここでEventのコンストラクタで指定する `manualReset` がfalseの場合、waitで制御を返した後、フラグをfalseに自動的に戻します。\nEventのコンストラクタの `initialState` は、このフラグの初期状態を表します。\n\n共有資源がある場合、通知する側はset以降の共有資源へのアクセス、通知される側はwait以前の共通資源へのアクセスについて、互いに競合しないよう排他する必要があります。\nEventでは通知する側はsetより前に共有資源の編集を終え、通知される側はwait以降に共有資源を使うようにすればよいでしょう。\n\nSee_Also:\n    - https://dlang.org/phobos/core_sync_event.html\n\n$(WORKAROUND_ISSUE22230)\n",
    "line" : 313,
    "char" : 1,
    "endline" : 353,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "template_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/template_example.d",
  "comment" : "テンプレート\n\nテンプレートについてまとめます。\n- テンプレート\n- テンプレート関数\n- テンプレートクラス・構造体\n- mixinテンプレート(TODO)\n- enum, aliasのテンプレート(TODO)\n\nSee_Also:\n    - https://dlang.org/spec/template.html\n\nSource: $(LINK_TO_SRC source/_template_example.d)\nMacros:\n    TITLE=テンプレートの使用例\n",
  "members" : [
   {
    "name" : "__unittest_L23_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "テンプレートの例です\n",
    "line" : 23,
    "char" : 1,
    "endline" : 52,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L52_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "テンプレート関数の例です\n\nテンプレートを使った関数の定義・使い方の例です。\n構文糖によって通常のテンプレートを使うよりも見やすく、書きやすく使用することができます。\n",
    "line" : 52,
    "char" : 1,
    "endline" : 77,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L77_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ditto\n",
    "line" : 77,
    "char" : 1,
    "endline" : 103,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L103_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "テンプレートクラス・構造体の例です\n",
    "line" : 103,
    "char" : 1,
    "endline" : 130,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "typecons_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/typecons_example.d",
  "comment" : "型を作るユーティリティ\n\n様々な型を作れるtemplateを提供する`std.typecons`パッケージについて解説します。\n\nSource: $(LINK_TO_SRC source/_typecons_example.d)\nMacros:\n    TITLE=型を作るユーティリティ群の例\n",
  "members" : [
   {
    "name" : "__unittest_L18_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "nullになる可能性のある値を表現するNullableの例です\n\nNullableを利用することで、値が存在しない可能性のある型を表現できます。\nint等の組み込み型やstructについても、nullとなることを明確に示せます。\n",
    "line" : 18,
    "char" : 1,
    "endline" : 67,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L67_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ポインタを格納するためのNullableであるNullableRefの例です\n\nポインタ型の場合はポインタだけでnullの状態を表現できるため、NullableRefを利用することでサイズを節約できます。\n",
    "line" : 67,
    "char" : 1,
    "endline" : 101,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L101_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "constやimmutableの参照型の変数でも再代入可能とするRebindableの例です\n\nconstやimmutableの参照型の変数はそのままでは再代入できませんが、Rebindableでラップした変数は再代入可能になります。\n",
    "line" : 101,
    "char" : 1,
    "endline" : 136,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L136_C7",
    "kind" : "function",
    "protection" : "public",
    "comment" : "コピー不能であったり、デストラクタを持っていたりする構造体を複数の変数で共有、参照する例です。\n\nポインタでも参照させることは可能ですが、デストラクタの呼び出しを自動で安全に行うために `RefCounted` を使う方法があります。\n内部的には参照カウンタで管理されます。\n",
    "line" : 136,
    "char" : 7,
    "storageClass" : [
     "@nogc"
    ],
    "endline" : 213,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L213_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "classのインスタンスをスタック上に確保するscopedの例です\n\nscopedによりclassのインスタンスを生成した場合、ヒープを使用するnewのオーバーヘッドを回避することができます。\nその代わり、インスタンスをスコープの外に移動させることはできません。\n",
    "line" : 213,
    "char" : 1,
    "endline" : 267,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L267_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "複数の値の組を作れる`Tuple`の例です。\n\n複数の異なる型の値をまとめて扱いたい時や、関数から複数の値を返したい場合などに利用できます。\n",
    "line" : 267,
    "char" : 1,
    "endline" : 341,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "uda_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/uda_example.d",
  "comment" : "UDA(User Defined Attribute)\n\nUDA(User Defined Attribute、ユーザー定義属性)の使用例についてまとめます。\n\nSource: $(LINK_TO_SRC source/_uda_example.d)\nMacros:\n    TITLE=ユーザー定義属性の例\n",
  "members" : [
   {
    "name" : "__unittest_L15_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "UDA取得の例です\n",
    "line" : 15,
    "char" : 1,
    "endline" : 35,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L35_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "特定のUDAを持ったメンバー抽出の例です\n",
    "line" : 35,
    "char" : 1,
    "endline" : 68,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L68_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "toStringの自動生成の例です\n",
    "line" : 68,
    "char" : 1,
    "endline" : 116,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L116_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "関数の引数に付与されたUDAを取得する例です\n",
    "line" : 116,
    "char" : 1,
    "endline" : 133,
    "endchar" : 1
   }
  ]
 },
 {
  "name" : "unittests_example",
  "kind" : "module",
  "file" : "/home/runner/work/Cookbook/Cookbook/source/unittests_example.d",
  "comment" : "単体テスト\n\n様々な単体テストの記法についてまとめます。\n\nSource: $(LINK_TO_SRC source/_unittests_example.d)\nMacros:\n    TITLE=単体テストの例\n",
  "members" : [
   {
    "name" : "__unittest_L19_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "unittestとassert\n\n実行時ロジックについては、`assert` を使ってテストを記述します。\n\nunittestとassertは両方共debugビルドのときにのみ使われ、releaseビルドのときには除去されます。\n",
    "line" : 19,
    "char" : 1,
    "endline" : 41,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L41_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "unittestとstatic assert\n\nコンパイル時に確定する内容については、`static assert`を使ってテストを記述します。\n\nこのテストに失敗するとコンパイルエラーになります。\n",
    "line" : 41,
    "char" : 1,
    "endline" : 60,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L60_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "例外が発生することをテストする方法\n\n`assertThrown` 関数を使い、対象の関数が例外を発生させることを確認します。\nここでは関数の事前条件チェックでAssertErrorが起きることを確認します。\n\ncore.exception : $(LINK https://dlang.org/phobos/core_exception.html)$(BR)\nstd.exception : $(LINK https://dlang.org/phobos/std_exception.html)$(BR)\n",
    "line" : 60,
    "char" : 1,
    "endline" : 100,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L100_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "@safe や @nogc 、nothrowであることを保証する方法\n\n属性をテストするには unittest自体を当該属性で修飾する方法が多く使われます。\nこのテストサンプルは `nothrow` 属性で修飾されています。\n\n`std.traits` の機能で関数属性を取り出すことも可能ですが、ブロック全体を修飾することで漏れがなくなります。\n",
    "line" : 100,
    "char" : 9,
    "storageClass" : [
     "nothrow"
    ],
    "endline" : 121,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L121_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "浮動小数点数をテストする方法\n\n数値計算の結果は厳密なテストが難しいため `isClose` を使い相対誤差などを利用した比較を行います。\n\nstd.math.isClose : $(LINK https://dlang.org/phobos/std_math.html#.isClose)$(BR)\n\n類似の `approxEqual` はDMDのバージョンで非推奨となったため、 `isClose` を使うことが推奨されています。\n",
    "line" : 121,
    "char" : 1,
    "endline" : 156,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L156_C1",
    "kind" : "function",
    "protection" : "public",
    "comment" : "一般的なRangeの内容をテストする方法\n\nstd.algorithm 内の equal 関数を使ってRange同士を比較します。\n\nstd.algorithm : $(LINK https://dlang.org/phobos/std_algorithm_comparison.html)\n",
    "line" : 156,
    "char" : 1,
    "endline" : 181,
    "endchar" : 1
   },
   {
    "name" : "__unittest_L181_C9",
    "kind" : "function",
    "protection" : "public",
    "comment" : "ファイルの生成などを確認する方法\n\n単体テストはそれぞれが独立し、順不同および繰り返し実行できることが重要です。\n\n最初と `scope(exit)` でファイルの破棄を行うとテストの再現性や独立性が高まります。\n",
    "line" : 181,
    "char" : 9,
    "storageClass" : [
     "@system"
    ],
    "endline" : 196,
    "endchar" : 1
   }
  ]
 }
]
