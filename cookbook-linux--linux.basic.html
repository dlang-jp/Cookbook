
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>linux.basic - D言語クックブック</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <a class='githublinkimg' href="https://github.com/dlang-jp/Cookbook"><img src="img/GitHub-Mark-32px.png" width="32" height="32" /></a>
        <h2>D言語クックブック</h2>
        <p><span class="smallprint"><b>version:</b> ~master <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	

	<li><a href="cookbook--array_example.html"><span >配列</span></a></li>



	<li><a href="cookbook--assoc_array_example.html"><span >連想配列</span></a></li>



	<li><a href="cookbook--concurrency_example.html"><span >並行処理</span></a></li>



	<li><a href="cookbook--container_example.html"><span >コンテナ</span></a></li>


	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >データ形式
		</span></a><ul><li><a href="
			cookbook--data.html"><span >overview</span></a></li>
			

	<li><a href="cookbook--data.base64_example.html"><span >Base64エンコード/デコード</span></a></li>



	<li><a href="cookbook--data.csv_example.html"><span >CSV操作</span></a></li>



	<li><a href="cookbook--data.json_example.html"><span >JSON操作</span></a></li>



	<li><a href="cookbook--data.zip_example.html"><span >ZIP操作</span></a></li>

</ul></li>
	
	





	<li><a href="cookbook--datetime_example.html"><span >時刻・日付</span></a></li>



	<li><a href="cookbook--exception_example.html"><span >例外</span></a></li>



	<li><a href="cookbook--file_example.html"><span >ファイルシステム</span></a></li>



	<li><a href="cookbook--gc_example.html"><span >ガベージコレクション</span></a></li>



	<li><a href="cookbook--getopt_example.html"><span >コマンドライン解析</span></a></li>



	<li><a href="cookbook--hash_example.html"><span >ハッシュ値の計算</span></a></li>



	<li><a href="cookbook--is_example.html"><span >is式</span></a></li>



	<li><a href="cookbook--meta_example.html"><span >メタプログラミング</span></a></li>



	<li><a href="cookbook--network_example.html"><span >ネットワーク(cURL)</span></a></li>



	<li><a href="cookbook--numeric_example.html"><span >数値計算</span></a></li>



	<li><a href="cookbook--opovl_excample.html"><span >演算子オーバーロード</span></a></li>



	<li><a href="cookbook--parallelism_example.html"><span >並列処理</span></a></li>



	<li><a href="cookbook--process_example.html"><span >プロセス</span></a></li>



	<li><a href="cookbook--random_example.html"><span >乱数</span></a></li>



	<li><a href="cookbook--range_example.html"><span >レンジ</span></a></li>



	<li><a href="cookbook--regex_example.html"><span >正規表現</span></a></li>



	<li><a href="cookbook--sorting_example.html"><span >データの並び替え・応用</span></a></li>



	<li><a href="cookbook--string_example.html"><span >文字列</span></a></li>



	<li><a href="cookbook--sumtype_example.html"><span >SumTypeの例</span></a></li>



	<li><a href="cookbook--sync_example.html"><span >同期機構/排他処理</span></a></li>



	<li><a href="cookbook--template_example.html"><span >テンプレート</span></a></li>



	<li><a href="cookbook--typecons_example.html"><span >型を作るユーティリティ</span></a></li>



	<li><a href="cookbook--uda_example.html"><span >UDA(User Defined Attribute)</span></a></li>



	<li><a href="cookbook--unittests_example.html"><span >単体テスト</span></a></li>





	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >subpkg</span></a><ul>
			

	<li><a href="cookbook-subpkg--subpkg.test.html"><span >サブパッケージの作り方</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >windows</span></a><ul>
			

	<li><a href="cookbook-windows--windows.basic.html"><span >Win32API</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >posix</span></a><ul>
			

	<li><a href="cookbook-posix--posix.basic.html"><span >POSIX</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >linux</span></a><ul>
			

	<li><a href="cookbook-linux--linux.basic.html"><span >Linux</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >libdparse_usage</span></a><ul>
			

	<li><a href="cookbook-libdparse_usage--libdparse_usage.example.html"><span >libdparse</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >asdf_usage</span></a><ul>
			

	<li><a href="cookbook-asdf_usage--asdf_usage.example.html"><span >Asdfの使用例</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >vibed_usage</span></a><ul>
			

	<li><a href="cookbook-vibe-d_usage--vibed_usage.auth.html"><span >認証・権限</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.http.html"><span >HTTPサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.https.html"><span >HTTPSサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.rest.html"><span >RESTインターフェースの利用</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.web.html"><span >Webインターフェースの利用</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                
                <div class="quickindex" id="quickindex"></div>
                
                <h1><div class="ddoc_summary">Linux
</div></h1><div class="ddoc_description">LinuxのAPIの呼び出しについてまとめます。
<div class="ddoc_blankline"></div>

概要
2023年現在の公式ドキュメントには記載がありませんが、<span class="d_inlinecode donthyphenate notranslate">core.sys.linux</span>パッケージにはLinuxの関数宣言・構造体定義が存在し、
<span class="d_inlinecode donthyphenate notranslate">import core.sys.linux.io_uring;</span> のように<span class="d_inlinecode donthyphenate notranslate">import</span>を行うことで各関数を利用できます。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">core.sys.linux</span>パッケージはLinux環境でのみ利用できるため、
利用する場合は <span class="d_inlinecode donthyphenate notranslate">version (linux) { } else { }</span> といった形で<span class="d_inlinecode donthyphenate notranslate">version</span>によるプラットフォームの明記を行うことをお勧めします。<br>
以下の例ではWindows等の環境でもビルドできるようにするためversionで囲って表記しています。

</div>
<div class="ddoc_see_also"><span class="ddoc_see_also_header">See Also:</span>
 必要な関数・構造体が利用できるかは、DMDのソースコードを確認する必要があります。<br>
    <a href="https://github.com/dlang/dmd/tree/master/druntime/src/core/sys/linux">https://github.com/dlang/dmd/tree/master/druntime/src/core/sys/linux</a>

</div>
<div class="ddoc_section_nonstandard"><span class="ddoc_section_nonstandard_header">Source:</span>
<span class="link_to_source"><a href="https://github.com/dlang-jp/Cookbook/tree/master/posix/source/linux/basic.d">https://github.com/dlang-jp/Cookbook/tree/master/posix/source/linux/basic.d</a></span></div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 LinuxのAPIを直接利用したechoサーバー・クライアントの例です。
<pre class="d_code notranslate"><span class="d_keyword">version</span> (linux)
{
    <span class="d_comment">// 利用するLinuxのモジュールをimportする
</span>    <span class="d_keyword">import</span> core.sys.linux.unistd;
    <span class="d_keyword">import</span> core.sys.linux.fcntl;
    <span class="d_keyword">import</span> core.sys.linux.epoll;
    <span class="d_keyword">import</span> core.stdc.errno;
    <span class="d_keyword">import</span> core.sys.linux.sys.socket;
    <span class="d_keyword">import</span> core.sys.linux.netinet.in_;

    <span class="d_keyword">import</span> std.algorithm : map;
    <span class="d_keyword">import</span> std.container : Array;
    <span class="d_keyword">import</span> std.exception : enforce, errnoEnforce, ErrnoException;
    <span class="d_keyword">import</span> std.range : cycle, take, array;
    <span class="d_keyword">import</span> std.typecons : Nullable, nullable;

    <span class="d_comment">// ソケットをノンブロッキングにする関数
</span>    <span class="d_keyword">void</span> toNonBlock(<span class="d_keyword">int</span> fd)
    {
        <span class="d_keyword">immutable</span> flags = fcntl(fd, F_GETFL, 0);
        errnoEnforce(fcntl(fd, F_SETFL, flags | O_NONBLOCK) != -1);
    }

    <span class="d_comment">// 成功またはIO待ちでなければエラーにする関数
</span>    <span class="d_comment">// IO待ち発生時は結果がisNullになる
</span>    Nullable!T ioEnforce(
        T, string file = <span class="d_keyword">__FILE__</span>, <span class="d_keyword">ulong</span> line = <span class="d_keyword">__LINE__</span>)(T result)
    {
        <span class="d_keyword">if</span> (result != -1)
        {
            <span class="d_keyword">return</span> nullable(result);
        }

        <span class="d_keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)
        {
            <span class="d_comment">// EAGAIN・EWOULDBLOCKはクリア
</span>            errno = 0;
            <span class="d_keyword">return</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">return</span>).init;
        }

        <span class="d_keyword">throw</span> <span class="d_keyword">new</span> ErrnoException(<span class="d_keyword">null</span>, file, line);
    }

    <span class="d_comment">// IO結果
</span>    <span class="d_keyword">struct</span> IOResult
    {
        <span class="d_comment">// 送受信バイト数
</span>        ssize_t n;

        <span class="d_comment">// 接続先がcloseされたか
</span>        <span class="d_keyword">bool</span> isClosed;
    }

    <span class="d_comment">// ノンブロッキング送信関数
</span>    IOResult nonBlockingSend(<span class="d_keyword">int</span> fd, <span class="d_keyword">const</span>(<span class="d_keyword">void</span>)[] data)
    {
        <span class="d_comment">// dataをすべて送信し切るか、接続先がshutdownされるまで送信実行
</span>        IOResult result;
        <span class="d_keyword">while</span> (result.n &lt; data.length &amp;&amp; !result.isClosed)
        {
            <span class="d_keyword">immutable</span> rest = <span class="d_keyword">cast</span>(<span class="d_keyword">uint</span>)(data.length - result.n);
            <span class="d_keyword">immutable</span> r = ioEnforce(send(fd, &amp;data[result.n], rest, 0));
            <span class="d_keyword">if</span> (r.isNull)
            {
                <span class="d_comment">// IO待ちが発生したので中断
</span>                <span class="d_keyword">break</span>;
            }

            <span class="d_comment">// 送信バイト数を加算。0バイト送信時は接続先にshutdownされている
</span>            result.n += r.get;
            result.isClosed = r.get == 0;
        }
        <span class="d_keyword">return</span> result;
    }

    <span class="d_comment">// ノンブロッキング受信関数
</span>    IOResult nonBlockingReceive(<span class="d_keyword">int</span> fd, <span class="d_keyword">void</span>[] buffer)
    {
        <span class="d_comment">// bufferにすべて受信し切るか、接続先がshutdownされるまで受信実行
</span>        IOResult result;
        <span class="d_keyword">while</span> (result.n &lt; buffer.length &amp;&amp; !result.isClosed)
        {
            <span class="d_keyword">immutable</span> rest = <span class="d_keyword">cast</span>(<span class="d_keyword">uint</span>)(buffer.length - result.n);
            <span class="d_keyword">immutable</span> r = ioEnforce(recv(fd, &amp;buffer[result.n], rest, 0));
            <span class="d_keyword">if</span> (r.isNull)
            {
                <span class="d_comment">// IO待ちが発生したので中断
</span>                <span class="d_keyword">break</span>;
            }

            <span class="d_comment">// 受信バイト数を加算。0バイト受信時は接続先にshutdownされている
</span>            result.n += r.get;
            result.isClosed = r.get == 0;
        }
        <span class="d_keyword">return</span> result;
    }

    <span class="d_comment">// サーバー側listen用ソケットを生成する
</span>    <span class="d_keyword">immutable</span> listenerSocket = socket(AF_INET, SOCK_STREAM, 0);
    errnoEnforce(listenerSocket &gt;= 0);
    <span class="d_keyword">scope</span>(exit) close(listenerSocket);
    toNonBlock(listenerSocket);

    <span class="d_comment">// ローカルホストのアドレスにbindする
</span>    sockaddr_in listenAddress = {
        sin_family: AF_INET,
        sin_addr: {
            s_addr: htonl(INADDR_LOOPBACK),
        },
        <span class="d_comment">// 未使用ポートを自動で割り当てる
</span>        sin_port: 0,
    };
    errnoEnforce(bind(
        listenerSocket,
        <span class="d_keyword">cast</span>(<span class="d_keyword">const</span>(sockaddr)*) &amp;listenAddress,
        <span class="d_keyword">cast</span>(socklen_t) listenAddress.sizeof) == 0);

    <span class="d_comment">// bindされたアドレスを調べる
</span>    listenAddress = listenAddress.init;
    socklen_t addressLength = <span class="d_keyword">cast</span>(socklen_t) listenAddress.sizeof;
    errnoEnforce(getsockname(
        listenerSocket, <span class="d_keyword">cast</span>(sockaddr*) &amp;listenAddress, &amp;addressLength) == 0);

    <span class="d_comment">// listen開始
</span>    errnoEnforce(listen(listenerSocket, 1) == 0);

    <span class="d_comment">// クライアントソケットを生成する
</span>    <span class="d_keyword">immutable</span> clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    errnoEnforce(clientSocket &gt;= 0);
    <span class="d_keyword">scope</span>(exit) close(clientSocket);
    toNonBlock(clientSocket);

    <span class="d_comment">// サーバーにconnectする
</span>    <span class="d_keyword">immutable</span> connectResult = connect(
        clientSocket,
        <span class="d_keyword">cast</span>(<span class="d_keyword">const</span>(sockaddr)*) &amp;listenAddress,
        <span class="d_keyword">cast</span>(socklen_t) listenAddress.sizeof);
    errnoEnforce(connectResult == 0 || errno == EINPROGRESS);

    <span class="d_comment">// EINPROGRESSをクリア
</span>    errno = 0;

    <span class="d_comment">// 送受信対象のデータ。1000バイトの適当なデータを生成
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">ubyte</span>)[] sendPacket = (<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>[])[1, 2, 3, 4])
        .cycle.take(1000).array;
    ptrdiff_t clientSendPos;

    <span class="d_comment">// サーバー側送受信バッファ
</span>    Array!<span class="d_keyword">ubyte</span> serverBuffer;
    ptrdiff_t serverSendPos;

    <span class="d_comment">// クライアント側送受信バッファ
</span>    Array!<span class="d_keyword">ubyte</span> clientBuffer;

    <span class="d_comment">// サーバー側のクライアントソケット
</span>    <span class="d_keyword">int</span> acceptedSocket = -1;

    <span class="d_comment">// クライアント側送信処理
</span>    <span class="d_keyword">void</span> clientSend()
    {
        <span class="d_keyword">immutable</span> result = nonBlockingSend(
            clientSocket, sendPacket[clientSendPos .. $]);
        clientSendPos += result.n;

        <span class="d_comment">// 送信中にはcloseされない想定
</span>        enforce(!result.isClosed, <span class="d_string">"server closed"</span>);
    }

    <span class="d_comment">// クライアント側受信処理
</span>    IOResult clientReceive()
    {
        <span class="d_keyword">ubyte</span>[16] buffer;
        <span class="d_keyword">immutable</span> result = nonBlockingReceive(clientSocket, buffer[]);
        clientBuffer.insertBack(buffer[0 .. result.n]);
        <span class="d_keyword">return</span> result;
    }

    <span class="d_comment">// サーバー側送信処理
</span>    <span class="d_keyword">void</span> serverSend()
    {
        <span class="d_keyword">immutable</span> result = nonBlockingSend(
            acceptedSocket, serverBuffer.data[serverSendPos .. $]);
        serverSendPos += result.n;

        <span class="d_comment">// 送信中にはcloseされない想定
</span>        enforce(!result.isClosed, <span class="d_string">"client closed"</span>);
    }

    <span class="d_comment">// サーバー側受信処理
</span>    IOResult serverReceive()
    {
        <span class="d_keyword">ubyte</span>[16] buffer;
        <span class="d_keyword">immutable</span> result = nonBlockingReceive(acceptedSocket, buffer[]);
        serverBuffer.insertBack(buffer[0 .. result.n]);
        <span class="d_keyword">return</span> result;
    }

    <span class="d_comment">// epollインスタンス生成
</span>    <span class="d_keyword">immutable</span> epollInstance = epoll_create1(0);
    errnoEnforce(epollInstance &gt;= 0);
    <span class="d_keyword">scope</span>(exit) close(epollInstance);

    <span class="d_comment">// リスナーソケットをepollインスタンスに登録
</span>    epoll_event listenerEvent = {
        events: EPOLLIN,
        data: { fd: listenerSocket }
    };
    errnoEnforce(epoll_ctl(
        epollInstance, EPOLL_CTL_ADD, listenerSocket, &amp;listenerEvent) == 0);

    <span class="d_comment">// クライアントソケットをepollインスタンスに登録
</span>    epoll_event clientEvent = {
        events: EPOLLIN | EPOLLOUT | EPOLLRDHUP,
        data: { fd: clientSocket }
    };
    errnoEnforce(epoll_ctl(
        epollInstance, EPOLL_CTL_ADD, clientSocket, &amp;clientEvent) == 0);

    <span class="d_comment">// クライアント・サーバーどちらも切断されるまで送受信実行
</span>    epoll_event[3] events;
    epoll_event acceptedEvent;
    <span class="d_keyword">for</span> (<span class="d_keyword">bool</span> clientClosed = <span class="d_keyword">false</span>, serverClosed = <span class="d_keyword">false</span>;
            !clientClosed || !serverClosed ;) {

        <span class="d_comment">// epoll_waitで待機。タイムアウト時はエラー
</span>        errnoEnforce(epoll_wait(epollInstance, &amp;events[0], events.length, 1000) &gt; 0);

        <span class="d_comment">// 発生した各イベントを処理する
</span>        <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> <span class="d_keyword">const</span> e; events)
        {
            <span class="d_comment">// エラーがあったら終了
</span>            enforce(!(e.events &amp; EPOLLERR), <span class="d_string">"EPOLLERR"</span>);

            <span class="d_comment">// リスナーソケットの場合
</span>            <span class="d_keyword">if</span> (e.data.fd == listenerSocket)
            {
                <span class="d_comment">// 接続要求があった場合、まだaccept前ならacceptする
</span>                <span class="d_keyword">if</span> ((e.events &amp; EPOLLIN) &amp;&amp; acceptedSocket == -1)
                {
                    <span class="d_keyword">immutable</span> accepted = ioEnforce(accept(listenerSocket, <span class="d_keyword">null</span>, <span class="d_keyword">null</span>));
                    <span class="d_keyword">if</span> (!accepted.isNull)
                    {
                        acceptedSocket = accepted.get;
                        toNonBlock(acceptedSocket);
                        acceptedEvent.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP;
                        acceptedEvent.data.fd = acceptedSocket;
                        errnoEnforce(epoll_ctl(
                            epollInstance, EPOLL_CTL_ADD, acceptedSocket, &amp;acceptedEvent) == 0);
                    }
                }
            }

            <span class="d_comment">// クライアントソケットの場合
</span>            <span class="d_keyword">if</span> (e.data.fd == clientSocket)
            {
                <span class="d_comment">// 書き込み可能の場合
</span>                <span class="d_keyword">if</span> (e.events &amp; EPOLLOUT)
                {
                    <span class="d_comment">// 送信データが残っていれば送受信
</span>                    <span class="d_keyword">if</span> (clientSendPos &lt; sendPacket.length)
                    {
                        clientSend();
                        clientReceive();
                    }
                    <span class="d_keyword">else</span>
                    {
                        <span class="d_comment">// 残データがなければ送信シャットダウン。以降はデータ受信のみ行う。
</span>                        errnoEnforce(shutdown(clientSocket, SHUT_WR) == 0);
                        clientEvent.events = EPOLLIN | EPOLLRDHUP;
                        clientEvent.data.fd = clientSocket;
                        errnoEnforce(epoll_ctl(
                            epollInstance, EPOLL_CTL_MOD, clientSocket, &amp;clientEvent) == 0);
                    }
                }

                <span class="d_comment">// 読み込み可能の場合、受信実行
</span>                <span class="d_keyword">if</span> (e.events &amp; EPOLLIN)
                {
                    serverClosed = clientReceive().isClosed;
                }

                <span class="d_comment">// クライアントソケット切断時。想定外の切断はエラー
</span>                <span class="d_keyword">if</span> (e.events &amp; EPOLLRDHUP)
                {
                    enforce(serverClosed, <span class="d_string">"unexpected server EPOLLRDHUP"</span>);
                }
            }

            <span class="d_comment">// サーバー側のクライアントソケットの場合
</span>            <span class="d_keyword">if</span> (acceptedSocket != -1 &amp;&amp; e.data.fd == acceptedSocket)
            {
                <span class="d_comment">// 書き込み可能の場合
</span>                <span class="d_keyword">if</span> (e.events &amp; EPOLLOUT)
                {
                    <span class="d_comment">// 送信データが残っていれば送信
</span>                    <span class="d_keyword">if</span> (serverSendPos &lt; serverBuffer.length)
                    {
                        serverSend();
                    }
                    <span class="d_keyword">else</span> <span class="d_keyword">if</span>(clientClosed)
                    {
                        <span class="d_comment">// 残データが無く、クライアントも送信完了していればシャットダウン
</span>                        <span class="d_comment">// 以降はデータ受信のみ行う
</span>                        errnoEnforce(shutdown(acceptedSocket, SHUT_WR) == 0);
                        acceptedEvent.events = EPOLLIN | EPOLLRDHUP;
                        acceptedEvent.data.fd = acceptedSocket;
                        errnoEnforce(epoll_ctl(
                            epollInstance, EPOLL_CTL_MOD, acceptedSocket, &amp;acceptedEvent) == 0);
                    }
                }

                <span class="d_comment">// 読み込み可能の場合、受信実行
</span>                <span class="d_keyword">if</span> (e.events &amp; EPOLLIN)
                {
                    clientClosed = serverReceive().isClosed;

                    <span class="d_comment">// 受信に応じてecho開始
</span>                    serverSend();
                }
            }
        }
    }

    <span class="d_comment">// 最終的な送受信結果が正しいかチェック
</span>    <span class="d_keyword">assert</span>(sendPacket == clientBuffer.data);
}
</pre>
</div>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>