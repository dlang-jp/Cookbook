
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>string_example - D言語クックブック</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <a class='githublinkimg' href="https://github.com/dlang-jp/Cookbook"><img src="img/GitHub-Mark-32px.png" width="32" height="32" /></a>
        <h2>D言語クックブック</h2>
        <p><span class="smallprint"><b>version:</b> ~master <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	

	<li><a href="cookbook--array_example.html"><span >配列</span></a></li>



	<li><a href="cookbook--assoc_array_example.html"><span >連想配列</span></a></li>



	<li><a href="cookbook--concurrency_example.html"><span >並行処理</span></a></li>



	<li><a href="cookbook--container_example.html"><span >コンテナ</span></a></li>


	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >データ形式
		</span></a><ul><li><a href="
			cookbook--data.html"><span >overview</span></a></li>
			

	<li><a href="cookbook--data.base64_example.html"><span >Base64エンコード/デコード</span></a></li>



	<li><a href="cookbook--data.csv_example.html"><span >CSV操作</span></a></li>



	<li><a href="cookbook--data.json_example.html"><span >JSON操作</span></a></li>



	<li><a href="cookbook--data.zip_example.html"><span >ZIP操作</span></a></li>

</ul></li>
	
	





	<li><a href="cookbook--datetime_example.html"><span >時刻・日付</span></a></li>



	<li><a href="cookbook--exception_example.html"><span >例外</span></a></li>



	<li><a href="cookbook--file_example.html"><span >ファイルシステム</span></a></li>



	<li><a href="cookbook--getopt_example.html"><span >コマンドライン解析</span></a></li>



	<li><a href="cookbook--is_example.html"><span >is式</span></a></li>



	<li><a href="cookbook--meta_example.html"><span >メタプログラミング</span></a></li>



	<li><a href="cookbook--network_example.html"><span >ネットワーク(cURL)</span></a></li>



	<li><a href="cookbook--numeric_example.html"><span >数値計算</span></a></li>



	<li><a href="cookbook--opovl_excample.html"><span >演算子オーバーロード</span></a></li>



	<li><a href="cookbook--parallelism_example.html"><span >並列処理</span></a></li>



	<li><a href="cookbook--process_example.html"><span >プロセス</span></a></li>



	<li><a href="cookbook--random_example.html"><span >乱数</span></a></li>



	<li><a href="cookbook--range_example.html"><span >レンジ</span></a></li>



	<li><a href="cookbook--regex_example.html"><span >正規表現</span></a></li>



	<li><a href="cookbook--string_example.html"><span >文字列</span></a></li>



	<li><a href="cookbook--sumtype_example.html"><span >SumTypeの例</span></a></li>



	<li><a href="cookbook--sync_example.html"><span >同期機構/排他処理</span></a></li>



	<li><a href="cookbook--template_example.html"><span >テンプレート</span></a></li>



	<li><a href="cookbook--typecons_example.html"><span >型を作るユーティリティ</span></a></li>



	<li><a href="cookbook--uda_example.html"><span >UDA(User Defined Attribute)</span></a></li>



	<li><a href="cookbook--unittests_example.html"><span >単体テスト</span></a></li>





	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >subpkg</span></a><ul>
			

	<li><a href="cookbook-subpkg--subpkg.test.html"><span >サブパッケージの作り方</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >windows</span></a><ul>
			

	<li><a href="cookbook-windows--windows.basic.html"><span >Win32API</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >libdparse_usage</span></a><ul>
			

	<li><a href="cookbook-libdparse_usage--libdparse_usage.example.html"><span >libdparse</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >asdf_usage</span></a><ul>
			

	<li><a href="cookbook-asdf_usage--asdf_usage.example.html"><span >Asdfの使用例</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >vibed_usage</span></a><ul>
			

	<li><a href="cookbook-vibe-d_usage--vibed_usage.auth.html"><span >認証・権限</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.http.html"><span >HTTPサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.https.html"><span >HTTPSサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.rest.html"><span >RESTインターフェースの利用</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.web.html"><span >Webインターフェースの利用</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                
                <div class="quickindex" id="quickindex"></div>
                
                <h1><div class="ddoc_summary">文字列
</div></h1><div class="ddoc_description">文字列操作についてまとめます。

</div>
<div class="ddoc_section_nonstandard"><span class="ddoc_section_nonstandard_header">TODO:</span>
置換(replace)</div>
<div class="ddoc_section_nonstandard"><span class="ddoc_section_nonstandard_header">Source:</span>
<span class="link_to_source"><a href="https://github.com/dlang-jp/Cookbook/tree/master/source/string_example.d">https://github.com/dlang-jp/Cookbook/tree/master/source/string_example.d</a></span></div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 D言語の文字列の種類
<div class="ddoc_blankline"></div>

D言語の文字列は、基本的に文字の配列で、特別な型やクラスがあるわけではありません。ただし、文字型はchar(UTF-8), wchar(UTF-16), dchar(UTF-32)があり、それぞれ修飾子がありますので、種類は多いです。
また、UTF-8, UTF-16, UTF-32 以外の文字コードは「バイト列(符号なし8bit整数の配列)」という扱いです。ただし、一部のライブラリや、C言語との受け渡しインターフェースなどには便宜上char型を使うことがあります。
<div class="ddoc_blankline"></div>

<table><tr><th><tr><th align="center">型修飾</th><th align="center">UTF-8</th><th align="center">UTF-16</th><th align="center">UTF-32</th><th align="center">それ以外</th></tr></th></tr><tbody><tr><td align="center">(none)</td><td align="center">char[]</td><td align="center">wchar[]</td><td align="center">dchar[]</td><td align="center">ubyte[]</td></tr>
<tr><td align="center">const型</td><td align="center">const(char)[]</td><td align="center">const(wchar)[]</td><td align="center">const(dchar)[]</td><td align="center">const(ubyte)[]</td></tr>
<tr><td align="center">inout型</td><td align="center">inout(char)[]</td><td align="center">inout(wchar)[]</td><td align="center">inout(dchar)[]</td><td align="center">inout(ubyte)[]</td></tr>
<tr><td align="center">shared型</td><td align="center">shared(char)[]</td><td align="center">shared(wchar)[]</td><td align="center">shared(dchar)[]</td><td align="center">shared(ubyte)[]</td></tr>
<tr><td align="center">const shared型</td><td align="center">const shared(char)[]</td><td align="center">const shared(wchar)[]</td><td align="center">const shared(dchar)[]</td><td align="center">const shared(ubyte)[]</td></tr>
<tr><td align="center">inout shared型</td><td align="center">inout shared(char)[]</td><td align="center">inout shared(wchar)[]</td><td align="center">inout shared(dchar)[]</td><td align="center">inout shared(ubyte)[]</td></tr>
<tr><td align="center">const inout型</td><td align="center">const inout(char)[]</td><td align="center">const inout(wchar)[]</td><td align="center">const inout(dchar)[]</td><td align="center">const inout(ubyte)[]</td></tr>
<tr><td align="center">const inout shared型</td><td align="center">const inout(shared char)[]</td><td align="center">const inout shared(wchar)[]</td><td align="center">const inout shared(dchar)[]</td><td align="center">const inout shared(ubyte)[]</td></tr>
<tr><td align="center">immutable型</td><td align="center">immutable(char)[]</td><td align="center">immutable(wchar)[]</td><td align="center">immutable(dchar)[]</td><td align="center">immutable(ubyte)[]</td></tr>
</tbody></table>
この中でも、特に利用頻度が高いのが<span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span>型で、これは文字列リテラルの型であり、特別に<span class="d_inlinecode donthyphenate notranslate">string</span>という別名が利用できます。
同様に、<span class="d_inlinecode donthyphenate notranslate">immutable(wchar)[]</span>には<span class="d_inlinecode donthyphenate notranslate">wstring</span>という別名が、<span class="d_inlinecode donthyphenate notranslate">immutable(dchar)[]</span>には<span class="d_inlinecode donthyphenate notranslate">dstring</span>という別名が、それぞれ利用できます。
<div class="ddoc_blankline"></div>

immutableはマルチスレッド間でクリティカルセクションなしに同時アクセスできたり、寿命を考えなくてもよい点、const型への暗黙変換ができる点などが便利です。
<div class="ddoc_blankline"></div>

以下のサンプルでは文字コード(UTF-8, UTF-16, UTF-32)のそれぞれの変換について説明します
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.utf: toUTF8, toUTF16, toUTF32, toUTF16z;
<span class="d_comment">// 日本語のあいうえおはUTF-8で15バイト
</span>string str1 = <span class="d_string">"あいうえお"</span>;
<span class="d_keyword">assert</span>(str1.length == 15);

<span class="d_comment">// "あいうえお"を5要素で扱いたい場合は、dstringを使用する
</span>dstring str2 = <span class="d_string">"あいうえお"d</span>;
<span class="d_keyword">assert</span>(str2.length == 5);

<span class="d_comment">// UTF-8からUTF-32への変換は toUTF32 でできます
</span>dstring str3 = str1.toUTF32();
<span class="d_keyword">assert</span>(str3 == str2);
<span class="d_comment">// 逆に、UTF-32からUTF-8は、toUTF8()
</span><span class="d_keyword">assert</span>(str2.toUTF8() == str1);

<span class="d_comment">// char型(UTF-8)の配列であるstr1でも、foreachで
</span><span class="d_comment">// dchar型(UTF-32)に変換して要素アクセスできます。
</span>size_t idx = 0;
<span class="d_keyword">foreach</span> (<span class="d_keyword">dchar</span> c; str1)
{
    <span class="d_keyword">assert</span>(str2[idx] == c);
    idx++;
}

<span class="d_comment">// UTF-16型へは toUTF16 を使います。
</span>wstring str4 = str1.toUTF16();
wstring str5 = str2.toUTF16();

<span class="d_comment">// string型(immutable(char)[]型)をchar[]型にする場合は、
</span><span class="d_comment">// .dupでコピーを行います。
</span><span class="d_keyword">char</span>[] str6 = str1.dup;

<span class="d_comment">// char[]型をstring型(immutable(char)[]型)にする場合は、
</span><span class="d_comment">// .idupで破壊されないメモリとしてコピーします
</span>string str7 = str6.idup;
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 文字列型の使い分け
<div class="ddoc_blankline"></div>

文字列の型は、おおむね次のような使い分けをします。

<ul><li>普段使いは<span class="d_inlinecode donthyphenate notranslate">string</span></li>
<li>関数引数で、関数が終わった後はメモリが破壊されてもいいなら<span class="d_inlinecode donthyphenate notranslate">const(char)[]</span></li>
<li>関数引数で、関数が終わった後にメモリが破壊されて困るなら<span class="d_inlinecode donthyphenate notranslate">string</span></li>
<li>1文字が1要素であってほしい場合は<span class="d_inlinecode donthyphenate notranslate">dchar[]</span>や<span class="d_inlinecode donthyphenate notranslate">dstring</span></li>
<li>N文字目を書き換えたい場合は<span class="d_inlinecode donthyphenate notranslate">dchar[]</span></li>
<li>Windows APIに渡すなら<span class="d_inlinecode donthyphenate notranslate">wchar[]</span>や<span class="d_inlinecode donthyphenate notranslate">const(wchar)[]</span>
</li>
</ul>
さらに、D言語では、スライスの型はありません。<span class="d_inlinecode donthyphenate notranslate">string</span>のスライスは<span class="d_inlinecode donthyphenate notranslate">string</span>だし、<span class="d_inlinecode donthyphenate notranslate">const(char)[]</span>のスライスは<span class="d_inlinecode donthyphenate notranslate">const(char)[]</span>です。
<pre class="d_code notranslate"><span class="d_comment">// ■ 普段使いは string で大丈夫です
</span>string str1 = <span class="d_string">"あいうえお"</span>;

<span class="d_comment">// ■ 関数引数で、関数が終わった後はメモリが破壊されてもいいなら
</span><span class="d_comment">// `const(char)[]`を使います。
</span><span class="d_comment">// サンプルとして、文字列から「あい」を見つける関数
</span><span class="d_comment">// 「あい」をさがした後は死んでもかまわないので、
</span><span class="d_comment">// 引数は const(char)[] が妥当でしょう。
</span><span class="d_keyword">bool</span> findLove(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] str)
{
    <span class="d_keyword">import</span> std.string;
    <span class="d_keyword">return</span> str.indexOf(<span class="d_string">"あい"</span>) != -1;
}
<span class="d_comment">// 関数を読んだ後でも引数が生き続けるケース
</span><span class="d_keyword">assert</span>(findLove(str1));
<span class="d_comment">// 関数を読んだ後に引数の寿命が終わり、メモリが破損するケース
</span>{
    <span class="d_keyword">char</span>[15] str2 = <span class="d_string">"かきくけこ"</span>;
    <span class="d_keyword">assert</span>(!findLove(str2[]));
}

<span class="d_comment">// ■ 関数引数で、関数が終わった後にメモリが破壊されて困るなら`string`
</span><span class="d_comment">// 以下のメンバ関数のsetName, のように、関数が終わった後で
</span><span class="d_comment">// 寿命が尽きてはいけない場合には、stringや、コピーを保存する必要があります。
</span><span class="d_keyword">struct</span> Data
{
    string name;
    <span class="d_keyword">void</span> setName(string str)
    {
        name = str;
    }
    <span class="d_keyword">void</span> setNameCopy(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] str)
    {
        <span class="d_comment">// idupをつけるとconst(char)[]やchar[]のコピーを作り、
</span>        <span class="d_comment">// string型にしてくれます。
</span>        name = str.idup;
    }
}
Data dat;
<span class="d_comment">// 関数を読んだ後でも引数が生き続けるケース
</span>dat.setName(str1);
<span class="d_keyword">assert</span>(dat.name == <span class="d_string">"あいうえお"</span>);
<span class="d_comment">// 関数を読んだ後に引数の寿命が終わり、メモリが破損するケース
</span>{
    <span class="d_keyword">char</span>[15] str3 = <span class="d_string">"かきくけこ"</span>;
    dat.setNameCopy(str3[]);
}
<span class="d_comment">// str3はすでに破棄されているが、コピーを取っているので
</span><span class="d_comment">// dat.nameにはアクセスできる
</span><span class="d_keyword">assert</span>(dat.name == <span class="d_string">"かきくけこ"</span>);

<span class="d_comment">// ■ 1文字が1要素であってほしい場合は`dchar[]`や`dstring`
</span>dstring str4 = <span class="d_string">"さしすせそ"</span>;
<span class="d_comment">// 以下のように文字数やN文字目の文字が欲しい場合、UTF-32を使います。
</span><span class="d_keyword">assert</span>(str4.length == 5);
<span class="d_keyword">assert</span>(str4[2] == 'す');

<span class="d_comment">// ■ N文字目を書き換えたい場合は`dchar[]`
</span><span class="d_keyword">dchar</span>[] str5 = <span class="d_string">"やかん"d</span>.dup;
str5[0] = 'ち';
<span class="d_keyword">assert</span>(str5 == <span class="d_string">"ちかん"d</span>);

<span class="d_comment">// ■ Windows APIに渡すなら`wchar[]`や`const(wchar)[]`
</span><span class="d_comment">// 特にWindowsAPIに渡す場合はtoUTF16z()を呼び出して
</span><span class="d_comment">// "\0"終端の文字列の先頭ポインタを得ることができ、
</span><span class="d_comment">// そのままLPCWSTR等の型を要求する関数へ渡すことができます
</span><span class="d_keyword">version</span> (Windows)
{
    <span class="d_keyword">import</span> std.utf: toUTF16z;
    <span class="d_keyword">import</span> core.sys.windows.windows: GetEnvironmentVariableW, NULL;
    GetEnvironmentVariableW(str1.toUTF16z(), NULL, 0);
}
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 文字列の連結➀
<div class="ddoc_blankline"></div>

文字列は単純な文字の配列なので、<span class="d_inlinecode donthyphenate notranslate">~</span>演算子で連結できます。
<pre class="d_code notranslate">string str1 = <span class="d_string">"あいうえお"</span>;
string str2 = <span class="d_string">"かきくけこ"</span>;
<span class="d_comment">// ~ で連結
</span><span class="d_keyword">assert</span>(str1 ~ str2 == <span class="d_string">"あいうえおかきくけこ"</span>);

<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] str3 = <span class="d_string">"さしすせそ"</span>;
<span class="d_keyword">char</span>[] str4 = <span class="d_string">"たちつてと"</span>.dup;

<span class="d_comment">// ~ による連結は、必ず新規でメモリを確保してコピーを作成するので、
</span><span class="d_comment">// char[]型にもstring型にもできます。
</span><span class="d_keyword">char</span>[] str5 = str1 ~ str3 ~ str4;
<span class="d_keyword">assert</span>(str5 == <span class="d_string">"あいうえおさしすせそたちつてと"</span>);

<span class="d_comment">// ただし、stringとchar[]型など、違う型修飾子が混じっている場合の
</span><span class="d_comment">// 連結後の型はchar[]型となるので、string型にするにはcastが必要です。
</span>string str6 = <span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>)(str1 ~ str3 ~ str4);
<span class="d_keyword">assert</span>(str6 == <span class="d_string">"あいうえおさしすせそたちつてと"</span>);

<span class="d_comment">// やってることはcast(immutable)と同じですが、assumeUniqueのほうが明示的です。
</span><span class="d_comment">// (ユニークと見なす＝ここ以外で参照していないメモリなので、immutableにして問題ないという意味)
</span><span class="d_keyword">import</span> std.exception: assumeUnique;
string str7 = assumeUnique(str1 ~ str3 ~ str4);
<span class="d_keyword">assert</span>(str7 == <span class="d_string">"あいうえおさしすせそたちつてと"</span>);

<span class="d_comment">// 伸展しながら連結する場合、 ~= を使用します。
</span><span class="d_comment">// これは、str2 = str2 ~ str3 と同じ意味となります。
</span>str2 ~= str3;
<span class="d_keyword">assert</span>(str2 == <span class="d_string">"かきくけこさしすせそ"</span>);
str2 ~= str4;
<span class="d_keyword">assert</span>(str2 == <span class="d_string">"かきくけこさしすせそたちつてと"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 文字列の連結➁
<div class="ddoc_blankline"></div>

事前に長さの分からない文字列を構築する場合、<span class="d_inlinecode donthyphenate notranslate">std.array</span> の <span class="d_inlinecode donthyphenate notranslate">appender</span> を使います。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">appender</span> : <a href="https://dlang.org/phobos/std_array.html#appender">https://dlang.org/phobos/std_array.html#appender</a>
<pre class="d_code notranslate"><span class="d_comment">// 多くの文字を連結するときはappenderを使います
</span>
<span class="d_keyword">import</span> std.array : appender;

<span class="d_keyword">auto</span> buffer = appender!string;

buffer.put(<span class="d_string">"https://"</span>);
buffer.put(<span class="d_string">"github.com"</span>);
buffer.put(<span class="d_string">"/dlang"</span>);

<span class="d_keyword">assert</span>(buffer.data == <span class="d_string">"https://github.com/dlang"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 書式化文字列
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">std.format</span> の <span class="d_inlinecode donthyphenate notranslate">format</span> を使います。
<div class="ddoc_blankline"></div>

<a href="https://dlang.org/phobos/std_format.html#.format">https://dlang.org/phobos/std_format.html#.format</a>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.format : format;

<span class="d_keyword">int</span> n = 10;
<span class="d_keyword">float</span> f = 1.5;
string url = <span class="d_string">"https://github.com"</span>;

<span class="d_keyword">auto</span> text = format!<span class="d_string">"%d, %f, %s"</span>(n, f, url);

<span class="d_keyword">assert</span>(text == <span class="d_string">"10, 1.500000, https://github.com"</span>, text);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 完全一致、辞書順での比較
<pre class="d_code notranslate"><span class="d_keyword">auto</span> text = <span class="d_string">"ABC"</span>;
<span class="d_keyword">assert</span>(text == <span class="d_string">"ABC"</span>);
<span class="d_keyword">assert</span>(text &lt; <span class="d_string">"abc"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 大文字小文字を無視して比較
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">std.uni</span> の <span class="d_inlinecode donthyphenate notranslate">icmp</span> を使います
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">icmp</span> : <a href="https://dlang.org/phobos/std_uni.html#icmp">https://dlang.org/phobos/std_uni.html#icmp</a>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.uni;

<span class="d_keyword">auto</span> text = <span class="d_string">"ABC"</span>;
<span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"abc"</span>) == 0);
<span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"ab"</span>) == 1);
<span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"abcd"</span>) == -1);

<span class="d_comment">// 使い方、戻り値のイメージ
</span><span class="d_comment">// "ABC" &gt; "ab"
</span><span class="d_comment">// "ABC" - "ab" &gt; 0
</span><span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"abc"</span>) == 0);
<span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"ab"</span>) &gt; 0);
<span class="d_keyword">assert</span>(icmp(text, <span class="d_string">"abcd"</span>) &lt; 0);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 「で始まる」「で終わる」の例
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">std.algorithm</span> の <span class="d_inlinecode donthyphenate notranslate">startsWith</span>, <span class="d_inlinecode donthyphenate notranslate">endsWith</span> を使います。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">startsWith</span> : <a href="https://dlang.org/phobos/std_algorithm_searching.html#.startsWith">https://dlang.org/phobos/std_algorithm_searching.html#.startsWith</a><br>
<span class="d_inlinecode donthyphenate notranslate">endsWith</span> : <a href="https://dlang.org/phobos/std_algorithm_searching.html#.endsWith">https://dlang.org/phobos/std_algorithm_searching.html#.endsWith</a>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.algorithm : startsWith, endsWith;

<span class="d_keyword">auto</span> text = <span class="d_string">"std.algorithm"</span>;

<span class="d_comment">// ～で始まる
</span><span class="d_keyword">assert</span>(startsWith(text, <span class="d_string">"std."</span>));
<span class="d_keyword">assert</span>(text.startsWith(<span class="d_string">"std."</span>));

<span class="d_comment">// ～で終わる
</span><span class="d_keyword">assert</span>(endsWith(text, <span class="d_string">".algorithm"</span>));
<span class="d_keyword">assert</span>(text.endsWith(<span class="d_string">".algorithm"</span>));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 文字列が出現する位置を検索します。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">std.string</span> の <span class="d_inlinecode donthyphenate notranslate">indexOf</span> を使用します。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">indexOf</span> : <a href="https://dlang.org/phobos/std_string.html#.indexOf">https://dlang.org/phobos/std_string.html#.indexOf</a>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.string : indexOf;

<span class="d_keyword">auto</span> text = <span class="d_string">"std.algorithm.searching"</span>;

<span class="d_keyword">assert</span>(indexOf(text, <span class="d_string">"search"</span>) == 14);
<span class="d_keyword">assert</span>(text.indexOf(<span class="d_string">"search"</span>) == 14);

<span class="d_comment">// 大文字小文字を無視することもできます
</span><span class="d_comment">// std.typeconsからYesやNoをimportして使います
</span><span class="d_keyword">import</span> std.typecons : Yes, No;
<span class="d_keyword">import</span> std.string : CaseSensitive;

<span class="d_keyword">auto</span> url = <span class="d_string">"https://github.com/dlang/dmd"</span>;
<span class="d_keyword">assert</span>(url.indexOf(<span class="d_string">"GITHUB"</span>, No.CaseSensitive));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 プログラムの整形文字列表現
<div class="ddoc_blankline"></div>

chompPrefixやstrip、outdent、などを使うことで、プログラム言語などの文字列表現をいい感じに記載することができます。
<div class="ddoc_blankline"></div>

ポイントはoutdentでインデントを解除することで、その前後にoutdentの入力にマッチするようにいい感じにchompPrefixで先頭の改行を削除したり、outdent結果を欲しい形に合うようにstripで先頭・末尾の改行を含む空白文字を削除するなどの前処理・後処理をします。
<div class="ddoc_blankline"></div>

パーサーを扱うようなプログラムなどで活躍します。
<div class="ddoc_blankline"></div>

<span class="d_inlinecode donthyphenate notranslate">outdent</span>: <a href="https://dlang.org/phobos/std_string.html#.outdent">https://dlang.org/phobos/std_string.html#.outdent</a><br>
<span class="d_inlinecode donthyphenate notranslate">chompPrefix</span>: <a href="https://dlang.org/phobos/std_string.html#.chompPrefix">https://dlang.org/phobos/std_string.html#.chompPrefix</a><br>
<span class="d_inlinecode donthyphenate notranslate">strip</span>: <a href="https://dlang.org/phobos/std_string.html#.strip">https://dlang.org/phobos/std_string.html#.strip</a>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.string: outdent, chompPrefix, strip;
<span class="d_keyword">auto</span> jv = JSONValue(
    [
        <span class="d_string">"one"</span>: JSONValue(1),
        <span class="d_string">"two"</span>: JSONValue(
        [
            JSONValue(2),
            JSONValue(<span class="d_string">"弐"</span>)
        ])
    ]);

<span class="d_comment">// jvを文字列化したものが正しいことをassertすると
</span><span class="d_comment">// 入れ子になっていると以下のようになってしまい、1行だと見づらいですね。
</span><span class="d_keyword">assert</span>(jv.toString() == <span class="d_string">`{"one":1,"two":[2,"弐"]}`</span>);

<span class="d_comment">// まして、整形したものｎあぁああああああああああ！！！！！
</span><span class="d_keyword">assert</span>(jv.toPrettyString() == <span class="d_string">"{\n    \"one\": 1,\n    \"two\": [\n        2,\n        \"弐\"\n    ]\n}"</span>);

<span class="d_comment">// しかしながら、改行してしまうと以下のようにインデントが崩れてしまいます。
</span><span class="d_keyword">assert</span>(jv.toPrettyString() == <span class="d_string">`{
"one": 1,
"two": [
    2,
    "弐"
]
}`</span>);

<span class="d_comment">// これを解決するためには、以下のようにchompPrefix, outdentを使います。
</span><span class="d_keyword">assert</span>(jv.toPrettyString() == <span class="d_string">`
{
    "one": 1,
    "two": [
        2,
        "弐"
    ]
}`</span>.chompPrefix(<span class="d_string">"\n"</span>).outdent);

string fixLines(string s)
{
    <span class="d_keyword">version</span> (Windows)
    {
        <span class="d_keyword">import</span> std.array: replace;
        <span class="d_keyword">return</span> s.replace(<span class="d_string">"\r\n"</span>, <span class="d_string">"\n"</span>);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">return</span> s;
}

<span class="d_comment">// 最初にoutdent、次にstripでもOK。(この場合最後の改行もなくなる)
</span><span class="d_comment">// ついでに以下の例は q{ ... } の文字列表現です。
</span><span class="d_comment">// また、fixLinesを通すのは、q{ ... }が改行コードをそのまま拾ってしまうため
</span><span class="d_comment">// gitの設定如何でCRLFだったりLFだったりする場合があるのを均すためです。
</span><span class="d_keyword">assert</span>(jv.toPrettyString() == fixLines(<span class="d_string">q{
    {
        "one": 1,
        "two": [
            2,
            "弐"
        ]
    }
}</span>.outdent.strip));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 16進数文字列の変換
<div class="ddoc_blankline"></div>

バイト列を16進数の文字列で表現したものをバイト列に変換するのと、その逆を行います。
<div class="ddoc_blankline"></div>

See_Also:
<ul><li><a href="https://dlang.org/phobos/std_conv.html#hexString">https://dlang.org/phobos/std_conv.html#hexString</a></li>
<li><a href="https://dlang.org/phobos/std_conv.html#to">https://dlang.org/phobos/std_conv.html#to</a></li>
<li><a href="https://dlang.org/phobos/std_range.html#chunks">https://dlang.org/phobos/std_range.html#chunks</a></li>
<li><a href="https://dlang.org/phobos/std_algorithm_iteration.html#.map">https://dlang.org/phobos/std_algorithm_iteration.html#.map</a></li>
<li><a href="https://dlang.org/phobos/std_array.html#.array">https://dlang.org/phobos/std_array.html#.array</a></li>
<li><a href="https://dlang.org/phobos/std_format.html#.format">https://dlang.org/phobos/std_format.html#.format</a></li>
<li><a href="https://dlang.org/phobos/std_digest.html#.toHexString">https://dlang.org/phobos/std_digest.html#.toHexString</a></li>
</ul>
<pre class="d_code notranslate"><span class="d_comment">// コンパイル時に、バイト列を16進数の文字列で表現したものをバイト列に変換
</span><span class="d_keyword">import</span> std.conv: hexString;
<span class="d_keyword">static</span> <span class="d_keyword">immutable</span> bindat = hexString!<span class="d_string">"010203a4b5c6"</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(bindat == [0x01, 0x02, 0x03, 0xa4, 0xb5, 0xc6]);

<span class="d_comment">// 実行時に、バイト列を16進数の文字列で表現したものをバイト列に変換
</span><span class="d_keyword">import</span> std.conv: to;
<span class="d_keyword">import</span> std.range: chunks;
<span class="d_keyword">import</span> std.algorithm: map;
<span class="d_keyword">import</span> std.array: array;
<span class="d_keyword">auto</span> hexstr = <span class="d_string">"010203a4b5c6"</span>;
<span class="d_keyword">auto</span> rtbindat = hexstr.chunks(2).map!(a =&gt; a.to!<span class="d_keyword">ubyte</span>(16)).array;
<span class="d_keyword">assert</span>(rtbindat == [0x01, 0x02, 0x03, 0xa4, 0xb5, 0xc6]);
<span class="d_comment">// コンパイル時でも行ける
</span><span class="d_keyword">static</span> <span class="d_keyword">immutable</span> ctbindat = <span class="d_string">"010203a4b5c6"</span>.chunks(2).map!(a =&gt; a.to!<span class="d_keyword">ubyte</span>(16)).array;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(ctbindat == [0x01, 0x02, 0x03, 0xa4, 0xb5, 0xc6]);

<span class="d_comment">// 実行時に、バイト列を16進数の文字列で表現したものに変換
</span><span class="d_keyword">import</span> std.format: format;
<span class="d_keyword">auto</span> rthexstr = format!<span class="d_string">"%(%02x%)"</span>(rtbindat);
<span class="d_keyword">assert</span>(rthexstr == <span class="d_string">"010203a4b5c6"</span>);
<span class="d_comment">// コンパイル時でも行ける
</span><span class="d_keyword">static</span> <span class="d_keyword">immutable</span> cthexstr = format!<span class="d_string">"%(%02x%)"</span>(ctbindat);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(cthexstr == <span class="d_string">"010203a4b5c6"</span>);

<span class="d_comment">// 本当はダイジェスト値用ですが、これでも大丈夫です。
</span><span class="d_comment">// formatより若干速いはず。
</span><span class="d_comment">// ただし、コンパイル時には使えません。
</span><span class="d_keyword">import</span> std.digest: toHexString, LetterCase;
<span class="d_keyword">assert</span>(rtbindat.toHexString() == <span class="d_string">"010203A4B5C6"</span>);
<span class="d_keyword">assert</span>(rtbindat.toHexString!(LetterCase.lower) == <span class="d_string">"010203a4b5c6"</span>);
</pre>
</div>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>