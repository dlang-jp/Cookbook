
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>data.json_example</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <h2>cookbook</h2>
        <p><span class="smallprint"><b>version:</b> ~master <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	

	<li><a href="cookbook--array_example.html"><span >配列</span></a></li>



	<li><a href="cookbook--assoc_array_example.html"><span >連想配列</span></a></li>



	<li><a href="cookbook--concurrency_example.html"><span >並行処理</span></a></li>


	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >データ形式
		</span></a><ul><li><a href="
			cookbook--data.html"><span >overview</span></a></li>
			

	<li><a href="cookbook--data.csv_example.html"><span >CSV操作</span></a></li>



	<li><a href="cookbook--data.json_example.html"><span >JSON操作</span></a></li>

</ul></li>
	
	





	<li><a href="cookbook--datetime_example.html"><span >時刻・日付</span></a></li>



	<li><a href="cookbook--file_example.html"><span >ファイルシステム</span></a></li>



	<li><a href="cookbook--getopt_example.html"><span >コマンドライン解析</span></a></li>



	<li><a href="cookbook--is_example.html"><span >is式</span></a></li>



	<li><a href="cookbook--meta_example.html"><span >メタプログラミング</span></a></li>



	<li><a href="cookbook--network_example.html"><span >ネットワーク(cURL)</span></a></li>



	<li><a href="cookbook--process_example.html"><span >プロセス</span></a></li>



	<li><a href="cookbook--random_example.html"><span >乱数</span></a></li>



	<li><a href="cookbook--range_example.html"><span >レンジ</span></a></li>



	<li><a href="cookbook--regex_example.html"><span >正規表現</span></a></li>



	<li><a href="cookbook--string_example.html"><span >文字列</span></a></li>



	<li><a href="cookbook--uda_example.html"><span >UDA(User Defined Attribute)</span></a></li>





	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >subpkg</span></a><ul>
			

	<li><a href="cookbook-subpkg--subpkg.test.html"><span >サブパッケージの作り方</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >windows</span></a><ul>
			

	<li><a href="cookbook-windows--windows.basic.html"><span >Win32API</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >libdparse_usage</span></a><ul>
			

	<li><a href="cookbook-libdparse_usage--libdparse_usage.example.html"><span >libdparse</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                
                <div class="quickindex" id="quickindex"></div>
                
                <h1><div class="ddoc_summary">JSON操作
</div></h1><div class="ddoc_description">JSONファイル/JSONデータの読み書き等操作を扱います。
ここでは、標準で備えているstd.jsonモジュールと、その中のJSONValueについて説明します。
このモジュールは、あくまでもJSONが最低限取り扱える程度の機能があって、速度や利便性は二の次です。
ほかにもサードパーティのライブラリとして、asdfを代表として、より高度な取り扱いができるライブラリがあります。</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>文字列⇔JSON</h1>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_comment">// 文字列からJSONValueを作成します。
</span><span class="d_keyword">auto</span> jv = JSONValue(<span class="d_string">"文字列"</span>);

<span class="d_comment">// JSONValueからJSONの文字列表現を取得したい場合は
</span><span class="d_comment">// `.toString()`メソッドを使用します。
</span><span class="d_keyword">assert</span>(jv.toString() == <span class="d_string">`"文字列"`</span>);
<span class="d_comment">// JSONValueが文字列であることを確認するには、`.type`プロパティを使用して
</span><span class="d_comment">// 以下のように`JSONType.string`と比較します。
</span><span class="d_keyword">assert</span>(jv.type == JSONType.string);
<span class="d_comment">// JSONValueから文字列を取り出す場合は、`.str`プロパティを使用して
</span><span class="d_comment">// 以下のようにします。
</span><span class="d_keyword">assert</span>(jv.str == <span class="d_string">"文字列"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>数値⇔JSON</h1>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.exception: assertThrown;
<span class="d_comment">// 数値(符号あり・符号なし)からJSONValueを作成します。
</span><span class="d_keyword">int</span>  x = -128;
<span class="d_keyword">uint</span> y = 0xff;
<span class="d_keyword">auto</span> jvx = JSONValue(x);
<span class="d_keyword">auto</span> jvy = JSONValue(y);

<span class="d_comment">// JSONValueからJSONの文字列表現を取得したい場合は
</span><span class="d_comment">// `.toString()`メソッドを使用します。
</span><span class="d_keyword">assert</span>(jvx.toString() == <span class="d_string">`-128`</span>);
<span class="d_keyword">assert</span>(jvy.toString() == <span class="d_string">`255`</span>);

<span class="d_comment">// JSONValueが数値であることを確認するには、`.type`プロパティを使用して、
</span><span class="d_comment">// 以下のように`JSONType.integer`や`JSONType.uinteger`と比較します。
</span><span class="d_keyword">assert</span>(jvx.type == JSONType.integer);
<span class="d_keyword">assert</span>(jvy.type == JSONType.uinteger);
<span class="d_comment">// JSONValueから数値を取り出す場合は、以下のように
</span><span class="d_comment">// `.integer`/`.uinteger`プロパティを使用します。
</span><span class="d_keyword">assert</span>(jvx.integer == -128);
<span class="d_keyword">assert</span>(jvy.uinteger == 255);

<span class="d_comment">// ちなみに、型を符号ありとなしで間違ってしまうと例外が投げられます
</span>assertThrown(jvx.uinteger == <span class="d_keyword">cast</span>(<span class="d_keyword">uint</span>)-128);

<span class="d_comment">// 符号ありのつもりなんだけど(十分格納可能な範囲の)符号なしも
</span><span class="d_comment">// 受け付けたい場合は以下のようにします (とても面倒)
</span><span class="d_keyword">long</span> z = jvy.type == JSONType.integer  ? jvy.integer
       : jvy.type == JSONType.uinteger ? jvy.uinteger : 0;
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>真偽値・null⇔JSON</h1>

真偽値(<code class="ddoc_keyword">true</code> / <code class="ddoc_keyword">false</code>)とnullの状態は、上記文字列や数値とは異なり、
それぞれ個別にJSONTypeが存在します。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.exception: assertThrown;

<span class="d_comment">// JSONValueを作る
</span><span class="d_keyword">auto</span> jvf = JSONValue(<span class="d_keyword">false</span>);
<span class="d_keyword">auto</span> jvt = JSONValue(<span class="d_keyword">true</span>);
<span class="d_keyword">auto</span> jvn = JSONValue(<span class="d_keyword">null</span>);

<span class="d_comment">// JSONValueからJSONの文字列表現を取得したい場合は
</span><span class="d_comment">// `.toString()`メソッドを使用します。
</span><span class="d_keyword">assert</span>(jvf.toString() == <span class="d_string">`false`</span>);
<span class="d_keyword">assert</span>(jvt.toString() == <span class="d_string">`true`</span>);
<span class="d_keyword">assert</span>(jvn.toString() == <span class="d_string">`null`</span>);

<span class="d_comment">// 真偽は`.type`で調べます
</span><span class="d_keyword">assert</span>(jvf.type == JSONType.false_);
<span class="d_keyword">assert</span>(jvt.type == JSONType.true_);
<span class="d_comment">// さすがに↑だけではつらい(というか不格好な)ので、
</span><span class="d_comment">// ↓でOKなようにプロパティがあります
</span><span class="d_keyword">assert</span>(!jvf.boolean);
<span class="d_keyword">assert</span>( jvt.boolean);

<span class="d_comment">// nullかどうかも`.type`で調べます
</span><span class="d_keyword">assert</span>(jvn.type == JSONType.null_);
<span class="d_comment">// is nullでは調べられません(コンパイルエラーが出ます)
</span><span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {
    <span class="d_keyword">assert</span>(jvn <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
}));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>配列⇔JSON</h1>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.exception: assertThrown;
<span class="d_keyword">import</span> std.string: chompPrefix, outdent;

<span class="d_comment">// JSONValueを作る
</span><span class="d_keyword">auto</span> jv1 = JSONValue([1,2,3,4,5]);
<span class="d_comment">// 値にはJSONValueを使うことで、数値と文字列などを混成できます。
</span><span class="d_keyword">auto</span> jv2 = JSONValue([JSONValue(1), JSONValue(<span class="d_string">"弐"</span>)]);

<span class="d_comment">// JSONの文字列表現は、`.toString()`メソッドで得られます。
</span><span class="d_keyword">assert</span>(jv1.toString() == <span class="d_string">`[1,2,3,4,5]`</span>);
<span class="d_keyword">assert</span>(jv2.toString() == <span class="d_string">`[1,"弐"]`</span>);

<span class="d_comment">// 配列ともなると文字列表現は整形したくなってきます。
</span><span class="d_comment">// `toPrettyString()`メソッドで整形された文字列が得られます。
</span><span class="d_keyword">assert</span>(jv2.toPrettyString() ==<span class="d_string">`
[
    1,
    "弐"
]`</span>.chompPrefix(<span class="d_string">"\n"</span>).outdent());

<span class="d_comment">// 連想配列かどうかは、`.type`と`JSONType.array`を比較します
</span><span class="d_keyword">assert</span>(jv1.type == JSONType.array);
<span class="d_keyword">assert</span>(jv2.type == JSONType.array);

<span class="d_comment">// 値へのアクセスは`[]`演算子オーバーロードを使うか、
</span><span class="d_comment">// `.array`プロパティを使います
</span><span class="d_comment">// ただし、`.array`プロパティはなぜか`@system`らしいです
</span>() @trusted {
    <span class="d_keyword">assert</span>(jv1.array[0].type == JSONType.integer);
    <span class="d_keyword">assert</span>(jv1.array[0].integer == 1);
} ();
<span class="d_keyword">assert</span>(jv2[1].type == JSONType.string);
<span class="d_keyword">assert</span>(jv2[1].str == <span class="d_string">"弐"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>連想配列⇔JSON</h1>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.exception: assertThrown;
<span class="d_keyword">import</span> std.string: chompPrefix, outdent;

<span class="d_comment">// JSONValueを作る
</span><span class="d_keyword">auto</span> jv1 = JSONValue([
    <span class="d_string">"いち"</span>: 1, <span class="d_string">"に"</span>: 2]);
<span class="d_comment">// 文字列以外はキーにできません。
</span><span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {
    <span class="d_keyword">auto</span> jv2 = JSONValue([
        1: <span class="d_string">"いち"</span>, 2: <span class="d_string">"に"</span>]);
}));
<span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {
    <span class="d_keyword">auto</span> jv2 = JSONValue([
        <span class="d_keyword">true</span>: <span class="d_string">"真"</span>, <span class="d_keyword">false</span>: <span class="d_string">"偽"</span>]);
}));
<span class="d_comment">// 値にはJSONValueを使うことで、数値と文字列などを混成できます。
</span><span class="d_keyword">auto</span> jv2 = JSONValue([
    <span class="d_string">"いち"</span>: JSONValue(1), <span class="d_string">"に"</span>: JSONValue(<span class="d_string">"弐"</span>)]);
<span class="d_comment">// キーは無理です
</span><span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {
    <span class="d_keyword">auto</span> jv3 = JSONValue([
        JSONValue(<span class="d_keyword">true</span>): JSONValue(<span class="d_string">"真"</span>),
        JSONValue(<span class="d_keyword">false</span>): JSONValue(<span class="d_string">"偽"</span>)]);
}));


<span class="d_comment">// JSONの文字列表現は、`.toString()`メソッドで得られます。
</span><span class="d_comment">// ただし、キーの並び順は不定(unordered)です。
</span><span class="d_keyword">auto</span> str = jv1.toString();
<span class="d_keyword">assert</span>(str == <span class="d_string">`{"いち":1,"に":2}`</span> || str == <span class="d_string">`{"に":2,"いち":1}`</span>);

<span class="d_comment">// 連想配列ともなると文字列表現は整形したくなってきます。
</span><span class="d_comment">// `toPrettyString()`メソッドで整形された文字列が得られます。
</span><span class="d_keyword">assert</span>(JSONValue([<span class="d_string">"壱"</span>: 1]).toPrettyString() ==<span class="d_string">`
{
    "壱": 1
}`</span>.chompPrefix(<span class="d_string">"\n"</span>).outdent());

<span class="d_comment">// 連想配列かどうかは、`.type`と`JSONType.object`を比較します
</span><span class="d_keyword">assert</span>(jv1.type == JSONType.object);
<span class="d_keyword">assert</span>(jv2.type == JSONType.object);

<span class="d_comment">// 値へのアクセスは`[]`演算子オーバーロードを使うか、
</span><span class="d_comment">// `.object`プロパティを使います
</span><span class="d_comment">// ただし、`.object`プロパティはなぜか`@system`らしいです
</span>() @trusted {
    <span class="d_keyword">assert</span>(jv1.object[<span class="d_string">"いち"</span>].type == JSONType.integer);
    <span class="d_keyword">assert</span>(jv1.object[<span class="d_string">"いち"</span>].integer == 1);
} ();
<span class="d_keyword">assert</span>(jv2[<span class="d_string">"に"</span>].type == JSONType.string);
<span class="d_keyword">assert</span>(jv2[<span class="d_string">"に"</span>].str == <span class="d_string">"弐"</span>);
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 <h1>JSONファイルの書き込み・読み込み</h1>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.json;
<span class="d_keyword">import</span> std.file;
<span class="d_keyword">enum</span> jsonTestFile = <span class="d_string">"json_example_filerw_test.json"</span>;

<span class="d_comment">// あとしまつ
</span><span class="d_keyword">scope</span> (exit)
{
    <span class="d_keyword">if</span> (jsonTestFile.exists)
        remove(jsonTestFile);
}

<span class="d_comment">// JSONValueを作る
</span><span class="d_keyword">auto</span> jv1 = JSONValue([
    <span class="d_string">"aaa"</span>: JSONValue([1UL,2UL,3UL]),
    <span class="d_string">"bbb"</span>: JSONValue([
        <span class="d_string">"bbb-1"</span>: 1,
        <span class="d_string">"bbb-2"</span>: 2,
    ]),
    <span class="d_string">"ccc"</span>: JSONValue(<span class="d_keyword">null</span>)
]);

<span class="d_comment">// JSONValueをファイルに保存します。
</span><span class="d_comment">// 単純に`toString()`メソッドや`toPrettyString()`メソッドで
</span><span class="d_comment">// JSONの文字列表現に直した後`std.file`などのファイル書き込みを行います。
</span>std.file.write(jsonTestFile, jv1.toPrettyString());

<span class="d_comment">// JSONファイルを読み込んで、JSONValueを得ます
</span><span class="d_comment">// というか、ファイルから読み込んだJSONの文字列表現を、`parseJSON()`関数
</span><span class="d_comment">// でJSONValueに変換します。
</span><span class="d_comment">// curlなどを使って取得したHTTPレスポンスを解析するときも同様に`parseJSON()`
</span><span class="d_comment">// 関数でJSONValueに変換できます。
</span><span class="d_keyword">auto</span> jv2 = std.file.readText(jsonTestFile).parseJSON();

<span class="d_comment">// ちゃんと読み込まれています
</span><span class="d_keyword">assert</span>(jv1[<span class="d_string">"aaa"</span>][0] == jv2[<span class="d_string">"aaa"</span>][0]);
<span class="d_comment">// ただし、注意点。
</span><span class="d_comment">// 一度保存された整数は、符号なし→符号ありになることがあります
</span><span class="d_keyword">assert</span>(jv1[<span class="d_string">"aaa"</span>][0].type != jv2[<span class="d_string">"aaa"</span>][0].type);
<span class="d_keyword">assert</span>(jv1[<span class="d_string">"aaa"</span>][0].type == JSONType.uinteger);
<span class="d_keyword">assert</span>(jv2[<span class="d_string">"aaa"</span>][0].type == JSONType.integer);
</pre>
</div>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>