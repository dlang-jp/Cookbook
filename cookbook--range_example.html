
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>レンジを扱う処理の例 - D言語クックブック</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <a class='githublinkimg' href="https://github.com/dlang-jp/Cookbook"><img src="img/GitHub-Mark-32px.png" width="32" height="32" /></a>
        <h2>D言語クックブック</h2>
        <p><span class="smallprint"><b>version:</b> ~master <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	

	<li><a href="cookbook--array_example.html"><span >配列</span></a></li>



	<li><a href="cookbook--assoc_array_example.html"><span >連想配列</span></a></li>



	<li><a href="cookbook--concurrency_example.html"><span >並行処理</span></a></li>



	<li><a href="cookbook--container_example.html"><span >コンテナ</span></a></li>


	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >データ形式
		</span></a><ul><li><a href="
			cookbook--data.html"><span >overview</span></a></li>
			

	<li><a href="cookbook--data.base64_example.html"><span >Base64エンコード/デコード</span></a></li>



	<li><a href="cookbook--data.csv_example.html"><span >CSV操作</span></a></li>



	<li><a href="cookbook--data.json_example.html"><span >JSON操作</span></a></li>



	<li><a href="cookbook--data.zip_example.html"><span >ZIP操作</span></a></li>

</ul></li>
	
	





	<li><a href="cookbook--datetime_example.html"><span >時刻・日付</span></a></li>



	<li><a href="cookbook--exception_example.html"><span >例外</span></a></li>



	<li><a href="cookbook--file_example.html"><span >ファイルシステム</span></a></li>



	<li><a href="cookbook--gc_example.html"><span >ガベージコレクション</span></a></li>



	<li><a href="cookbook--getopt_example.html"><span >コマンドライン解析</span></a></li>



	<li><a href="cookbook--hash_example.html"><span >ハッシュ値の計算</span></a></li>



	<li><a href="cookbook--is_example.html"><span >is式</span></a></li>



	<li><a href="cookbook--meta_example.html"><span >メタプログラミング</span></a></li>



	<li><a href="cookbook--network_example.html"><span >ネットワーク(cURL)</span></a></li>



	<li><a href="cookbook--numeric_example.html"><span >数値計算</span></a></li>



	<li><a href="cookbook--opovl_excample.html"><span >演算子オーバーロード</span></a></li>



	<li><a href="cookbook--parallelism_example.html"><span >並列処理</span></a></li>



	<li><a href="cookbook--process_example.html"><span >プロセス</span></a></li>



	<li><a href="cookbook--random_example.html"><span >乱数</span></a></li>



	<li><a href="cookbook--range_example.html"><span >レンジ</span></a></li>



	<li><a href="cookbook--regex_example.html"><span >正規表現</span></a></li>



	<li><a href="cookbook--sorting_example.html"><span >データの並び替え・応用</span></a></li>



	<li><a href="cookbook--string_example.html"><span >文字列</span></a></li>



	<li><a href="cookbook--sumtype_example.html"><span >SumTypeの例</span></a></li>



	<li><a href="cookbook--sync_example.html"><span >同期機構/排他処理</span></a></li>



	<li><a href="cookbook--template_example.html"><span >テンプレート</span></a></li>



	<li><a href="cookbook--typecons_example.html"><span >型を作るユーティリティ</span></a></li>



	<li><a href="cookbook--uda_example.html"><span >UDA(User Defined Attribute)</span></a></li>



	<li><a href="cookbook--unittests_example.html"><span >単体テスト</span></a></li>





	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >subpkg</span></a><ul>
			

	<li><a href="cookbook-subpkg--subpkg.test.html"><span >サブパッケージの作り方</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >windows</span></a><ul>
			

	<li><a href="cookbook-windows--windows.basic.html"><span >Win32API</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >posix</span></a><ul>
			

	<li><a href="cookbook-posix--posix.basic.html"><span >POSIX</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >linux</span></a><ul>
			

	<li><a href="cookbook-linux--linux.basic.html"><span >Linux</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >libdparse_usage</span></a><ul>
			

	<li><a href="cookbook-libdparse_usage--libdparse_usage.example.html"><span >libdparse</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >asdf_usage</span></a><ul>
			

	<li><a href="cookbook-asdf_usage--asdf_usage.example.html"><span >Asdfの使用例</span></a></li>


		</ul></li>
	







	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >vibed_usage</span></a><ul>
			

	<li><a href="cookbook-vibe-d_usage--vibed_usage.auth.html"><span >認証・権限</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.http.html"><span >HTTPサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.https.html"><span >HTTPSサーバー</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.rest.html"><span >RESTインターフェースの利用</span></a></li>



	<li><a href="cookbook-vibe-d_usage--vibed_usage.web.html"><span >Webインターフェースの利用</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                
                <div class="quickindex" id="quickindex"></div>
                
                <h1><div class="ddoc_summary">レンジ
</div></h1><div class="ddoc_description">レンジの操作についてまとめます。

<h2>レンジ(Range)とは</h2>

レンジ(Range)とは、配列やリストといった要素を順次アクセスできるものを一般化した概念です。
<div class="ddoc_blankline"></div>

D言語では、データ構造やアルゴリズムをレンジの仕様に合わせて実装することで、さまざまなメリットが得られます。

<ul><li>レンジの仕様に合ったデータ構造であれば、<span class="d_inlinecode donthyphenate notranslate">std.algorithm</span>などの既存ライブラリのアルゴリズムをそのまま適用できます。</li>
<li>レンジを扱えるようアルゴリズムや関数を実装することで、配列や<span class="d_inlinecode donthyphenate notranslate">std.container</span>などの既存のデータ構造に対してそのまま使用できます。</li>
<li>レンジの概念はD言語プログラマーの間に広く浸透しています。
  そのため、自作のデータ構造や関数をレンジの仕様に合わせてあれば、他のD言語プログラマーにも使い方がすぐに伝わります。
</li>
</ul>
<h2>参考</h2>

<ul><li><span class="d_inlinecode donthyphenate notranslate">std.range</span> : <a href="https://dlang.org/phobos/std_range.html">https://dlang.org/phobos/std_range.html</a></li>
<li><span class="d_inlinecode donthyphenate notranslate">std.algorithm</span> : <a href="https://dlang.org/phobos/std_algorithm.html">https://dlang.org/phobos/std_algorithm.html</a>
</li>
</ul>
</div>
<div class="ddoc_section_nonstandard"><span class="ddoc_section_nonstandard_header">TODO:</span>

<ul><li>配列・文字列をレンジとして利用する。</li>
<li>レンジの種類の紹介</li>
<li>std.rangeの各関数の紹介
<div class="ddoc_blankline"></div>

</li>
</ul>
</div>
<div class="ddoc_section_nonstandard"><span class="ddoc_section_nonstandard_header">Source:</span>
<span class="link_to_source"><a href="https://github.com/dlang-jp/Cookbook/tree/master/source/range_example.d">https://github.com/dlang-jp/Cookbook/tree/master/source/range_example.d</a></span>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 最小のレンジ(InputRange)を作る
<pre class="d_code notranslate"><span class="d_comment">// ここでは、簡単なレンジの構造体を作りながら、レンジの定義を説明します。
</span>
<span class="d_comment">/++
0からn未満の整数を取り出せるレンジを作ります。

値を取り出すためのレンジは、最低でも以下の3つが必ず必要です。

    * 要素がもう無いかどうかを示す`range.empty`
    * 現在の先頭要素を取得する`range.front`
    * 次の要素へ移動する`range.popFront()`

この3つのみを持つレンジをInputRangeと呼びます。
ほかのより高機能なレンジは、InputRangeを拡張した仕様を備えています。
(より高機能なレンジとして、位置の保存が行えるForwardRangeや、
 前後の両方に移動が行えるBidirectionalRangeがあります)

より詳細なInputRangeの仕様・規則については、
std.rangeのisInputRangeのドキュメントに記載があります。
https://dlang.org/phobos/std_range_primitives.html#isInputRange

レンジを実装する場合、それぞれの操作を
メンバ関数や通常の関数(UFCSを利用)として用意する必要があります。
今回は、メンバ関数として実装します。
+/</span>
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> IntRange
{
    <span class="d_keyword">int</span> i = 0;
    <span class="d_keyword">int</span> n;
    <span class="d_keyword">invariant</span> (i &lt;= n);

    <span class="d_comment">/// nを指定するコンストラクタ
</span>    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n)
    {
        <span class="d_keyword">this</span>.n = n;
    }

    <span class="d_comment">/// nに達していたら終了
</span>    @property <span class="d_keyword">bool</span> empty() <span class="d_keyword">const</span>
    {
        <span class="d_keyword">return</span> i == n;
    }

    <span class="d_comment">/// 現在の値を返す
</span>    @property <span class="d_keyword">int</span> front() <span class="d_keyword">const</span>
    <span class="d_keyword">in</span> (!empty)
    {
        <span class="d_keyword">return</span> i;
    }

    <span class="d_comment">/// 次の値に移動する
</span>    <span class="d_keyword">void</span> popFront()
    <span class="d_keyword">in</span> (!empty)
    {
        ++i;
    }
}

<span class="d_comment">// 型がInputRangeであるかは、std.rangeのisInputRangeで確認できます。
</span><span class="d_keyword">import</span> std.range : isInputRange;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isInputRange!IntRange);

<span class="d_comment">// InputRangeで行える操作は下記の通りです。
</span><span class="d_keyword">auto</span> r = IntRange(3);

<span class="d_comment">// 空かどうか確かめられます。
</span><span class="d_keyword">assert</span>(!r.empty);

<span class="d_comment">// 現在の先頭要素を取り出せます。
</span><span class="d_keyword">assert</span>(r.front == 0);

<span class="d_comment">// 次の要素に移動できます。
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 1);

<span class="d_comment">// 最後の値まで取り出すと、emptyがtrueになります。
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 2);
r.popFront();
<span class="d_keyword">assert</span>(r.empty);

<span class="d_comment">// 自作のレンジに対して、std.algorithmの関数を適用することができます。
</span><span class="d_keyword">import</span> std.algorithm : equal, filter;

<span class="d_comment">// std.algorithmのequal関数でIntRangeと配列を比較します。
</span><span class="d_keyword">assert</span>(equal(IntRange(5), [0, 1, 2, 3, 4]));

<span class="d_comment">// std.algorithmのfilter関数で、0から10までの間の奇数のみ取り出します。
</span><span class="d_keyword">auto</span> odds = filter!<span class="d_string">"a % 2 != 0"</span>(IntRange(10));
<span class="d_keyword">assert</span>(equal(odds, [1, 3, 5, 7, 9]));

<span class="d_comment">// レンジはforeachステートメントで巡回することも可能です。
</span><span class="d_keyword">int</span> i = 0;
<span class="d_keyword">foreach</span> (v; IntRange(5))
{
    <span class="d_keyword">assert</span>(v == i);
    ++i;
}

<span class="d_comment">// なお、IntRangeはより高機能なものがstd.rangeのiota関数として用意されています。
</span><span class="d_comment">// 自作せずにこちらを使用しましょう。
</span><span class="d_keyword">import</span> std.range : iota;

<span class="d_keyword">assert</span>(equal(iota(0, 5), IntRange(5)));
<span class="d_keyword">assert</span>(equal(filter!<span class="d_string">"a % 2 != 0"</span>(iota(0, 10)), [1, 3, 5, 7, 9]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 連番のレンジを作る<span class="d_inlinecode donthyphenate notranslate">iota</span>の例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : iota;
<span class="d_keyword">import</span> std.algorithm : equal;

<span class="d_comment">// 0〜4の5つの要素を持つレンジを作る例です。
</span><span class="d_keyword">assert</span>(iota(5).equal([0, 1, 2, 3, 4]));

<span class="d_comment">// [1, 5) の4つの要素を持つレンジを作る例です。
</span><span class="d_keyword">assert</span>(iota(1, 5).equal([1, 2, 3, 4]));

<span class="d_comment">// [1, 10) の範囲で2つおきの要素を持つレンジを作る例です。
</span><span class="d_keyword">assert</span>(iota(1, 10, 2).equal([1, 3, 5, 7, 9]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 引数に指定した要素だけのレンジを作る<span class="d_inlinecode donthyphenate notranslate">only</span>の例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : only;
<span class="d_keyword">import</span> std.algorithm : equal;

<span class="d_comment">// 指定要素だけを持つレンジを作れます。
</span><span class="d_keyword">assert</span>(only(1).equal([1]));

<span class="d_comment">// 複数指定も可能です。
</span><span class="d_keyword">assert</span>(only(1, 2, 3).equal([1, 2, 3]));

<span class="d_comment">// onlyでは動的メモリ確保無しでレンジを生成できます。
</span><span class="d_comment">// ただし要素のコピーが発生するので、
</span><span class="d_comment">// サイズが巨大になる場合は注意が必要です。
</span><span class="d_keyword">assert</span>((() @nogc <span class="d_keyword">nothrow</span> <span class="d_keyword">pure</span> @safe =&gt; only(1, 2, 3))().equal([1, 2, 3]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 引数に指定した要素を無限に繰り返す<span class="d_inlinecode donthyphenate notranslate">repeat</span>の例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : repeat;
<span class="d_keyword">import</span> std.algorithm : equal;

<span class="d_comment">// 5を繰り返すレンジを作ります。
</span><span class="d_keyword">auto</span> r = repeat(5);
<span class="d_keyword">assert</span>(r.front == 5);
<span class="d_keyword">assert</span>(!r.empty);

<span class="d_comment">// 次の要素も5です。
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 5);

<span class="d_comment">// ランダムアクセスも可能です。
</span><span class="d_keyword">assert</span>(r[0] == 5);
<span class="d_keyword">assert</span>(r[1024] == 5);

<span class="d_comment">// スライスも可能です。
</span><span class="d_keyword">assert</span>(r[0 .. 5].equal([5, 5, 5, 5, 5]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 指定された関数を使ってレンジを生成する<span class="d_inlinecode donthyphenate notranslate">generate</span>の例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : generate, take;
<span class="d_keyword">import</span> std.algorithm : equal;

<span class="d_comment">// 関数(クロージャ)の戻り値をレンジにします。
</span><span class="d_keyword">int</span> value = 1;
<span class="d_keyword">auto</span> r = generate!(() =&gt; value *= 2);

<span class="d_comment">// 生成時に一度関数が実行されます。
</span><span class="d_keyword">assert</span>(r.front == 2);

<span class="d_comment">// popFrontのたびに関数が実行されます。
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 4);

<span class="d_comment">// std.rangeのtakeで先頭から指定した数だけ要素を取り出せます。
</span><span class="d_keyword">assert</span>(r.take(4).equal([4, 8, 16, 32]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 漸化式のレンジを生成する<span class="d_inlinecode donthyphenate notranslate">recurrence</span>の例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : recurrence, take;
<span class="d_keyword">import</span> std.algorithm : equal;

<span class="d_comment">// recurrenceを使って階乗を計算します。
</span><span class="d_comment">// 漸化式を文字列で指定可能です。
</span><span class="d_comment">// aは状態を表す変数で、以前の実行結果が格納されます。
</span><span class="d_comment">// nには現在の実行回数が格納されます。
</span><span class="d_comment">// 関数の引数には初期状態を渡します。(漸化式が必要とする分だけ必要です)
</span><span class="d_comment">// 以下のように書くと、
</span><span class="d_comment">// 前回の実行結果 * 現在の実行回数(つまり階乗)を計算するレンジになります。
</span><span class="d_keyword">auto</span> r = recurrence!<span class="d_string">"a[n - 1] * n"</span>(1);
<span class="d_keyword">assert</span>(r.front == 1); <span class="d_comment">// 0!
</span>
<span class="d_comment">// popFrontで漸化式の関数が実行されます。
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 1); <span class="d_comment">// 1!
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 2); <span class="d_comment">// 2!
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 6); <span class="d_comment">// 3!
</span>r.popFront();
<span class="d_keyword">assert</span>(r.front == 24); <span class="d_comment">// 4!
</span>
<span class="d_comment">// 複数の状態を持つ漸化式も表現可能です。
</span><span class="d_comment">// 以下ではフィボナッチ数の計算を行います。
</span><span class="d_keyword">auto</span> fib = recurrence!((a, n) =&gt; a[n - 2] + a[n - 1])(1, 1);
<span class="d_keyword">assert</span>(fib.take(7).equal([1, 1, 2, 3, 5, 8, 13]));
</pre>
</div>
<div class="ddoc_examples"><span class="ddoc_examples_header">Examples:</span>
 動的配列とRangeのどちらにも使用できる関数を定義する例です。
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.range : isInputRange, isRandomAccessRange, only;

<span class="d_comment">// 配列向けの関数をimportしておくことで、
</span><span class="d_comment">// 動的配列とRangeのどちらにも使用できる関数が定義できます。
</span><span class="d_comment">// ただし、パフォーマンスが重要になる場合は、
</span><span class="d_comment">// 動的配列向けに最適化した実装を別途用意することも検討してください。
</span><span class="d_keyword">bool</span> myAny(InputRange, Element)(InputRange range, Element needle)
    <span class="d_keyword">if</span> (isInputRange!InputRange)
{
    <span class="d_keyword">import</span> std.range : empty, front, popFront;
    <span class="d_keyword">for</span> (; !range.empty; range.popFront())
    {
        <span class="d_keyword">if</span> (range.front == needle)
        {
            <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
        }
    }

    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
}

<span class="d_comment">// 自作関数を動的配列に対して使用
</span><span class="d_keyword">int</span>[] values = [1, 2, 3, 4];
<span class="d_keyword">assert</span>(myAny(values, 1));
<span class="d_keyword">assert</span>(!myAny(values, 100));

<span class="d_comment">// 動的配列ではないRangeに対しても利用可能
</span><span class="d_keyword">assert</span>(myAny(only(1), 1));
<span class="d_keyword">assert</span>(!myAny(only(1), 100));

<span class="d_comment">// 動的配列はstd.rangeやstd.algorithmの内部ではRangeと見なされます。
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isRandomAccessRange!(<span class="d_keyword">int</span>[]));

<span class="d_comment">// しかし、動的配列用のRangeのメンバーをstd.rangeからimportしないと、
</span><span class="d_comment">// 動的配列の各メンバーを利用することはできません。
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {
    values.empty;
    values.popFront;
    values.front;
    values.save;
    values.back;
    values.popBack;
}));

<span class="d_comment">// std.rangeから各メンバーをimportすることで
</span><span class="d_comment">// 動的配列をRangeとして扱えるようになります。
</span>{
    <span class="d_keyword">import</span> std.range : empty, front, popFront, save, back, popBack;

    <span class="d_keyword">assert</span>(!values.empty);
    <span class="d_keyword">assert</span>(values.front == 1);
    <span class="d_keyword">assert</span>(values.back == 4);

    <span class="d_keyword">auto</span> saved = values.save;

    values.popFront;
    <span class="d_keyword">assert</span>(values == [2, 3, 4]);
    values.popBack;
    <span class="d_keyword">assert</span>(values == [2, 3]);

    <span class="d_keyword">assert</span>(saved == [1, 2, 3, 4]);
}
</pre>
</div>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>